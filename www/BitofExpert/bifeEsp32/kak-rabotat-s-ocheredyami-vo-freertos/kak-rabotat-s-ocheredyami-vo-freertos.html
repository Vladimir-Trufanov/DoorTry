<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="как-работать-с-очередями-во-freertos-2024-11-29"><a href="https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/kak-rabotat-s-ocheredyami-vo-freertos/kak-rabotat-s-ocheredyami-vo-freertos.md">Как работать с очередями во FreeRTOS</a> [2024-11-29]</h2>
<p>Очереди очень полезны для безопасной передачи сообщений от одной задачи к другой. Обмен сообщениями между задачами выполняется по правилу FIFO (первым сообщение пришло - первым и уйдет), то есть новые данные добавляются в конец очереди и извлекаются из начала.</p>
<p>У FreeRTOS очень богатый API очередей, который предлагает большое число возможностей.</p>
<figure>
<img src="queue_animation.gif" alt="Запись в очередь для хранения 5 элементов и чтение из нее." /><figcaption>Запись в очередь для хранения 5 элементов и чтение из нее.</figcaption>
</figure>
<hr />
<h3 id="введение---быстрое-знакомство"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">Введение - быстрое знакомство</a></h3>
<h3 id="xqueuecreate---coздать-новую-очередь"><a href="#xqueuecreate---c%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D1%83%D1%8E-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C">xQueueCreate - coздать новую очередь</a></h3>
<h3 id="xqueuesend---пoместить-элемент-в-очередь"><a href="#xqueuesend---%D0%BF%D0%BE%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B2-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C">xQueueSend - пoместить элемент в очередь</a></h3>
<h3 id="xqueuereceive---выбрать-элемент-из-oчереди"><a href="#xqueuereceive---%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8%D0%B7-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8">xQueueReceive - выбрать элемент из oчереди</a></h3>
<h3 id="xqueuesendfromisr-и-xqueuereceivefromisr"><a href="#xqueuesendfromisr---xqueuereceivefromisr">xQueueSendFromISR и xQueueReceiveFromISR</a></h3>
<h3 id="скетч-передача-сообщения-из-задачи-и-прерывания-с-приемoм-в-основном-цикле"><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%B7-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8-%D0%B8-%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81-%D0%BF%D1%80%D0%B8%D0%B5%D0%BC%D0%BE%D0%BC-%D0%B2-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%BC-%D1%86%D0%B8%D0%BA%D0%BB%D0%B5">Скетч “Передача сообщения из задачи и прерывания с приемoм в основном цикле”</a></h3>
<h3 id="библиoграфия"><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F">Библиoграфия</a></h3>
<hr />
<h3 id="введение"><a href="https://techtutorialsx.com/2017/08/20/esp32-arduino-freertos-queues/">Введение</a></h3>
<p>Один очень важный аспект, о котором следует помнить, заключается в том, что данные, которые помещаются в очередь, копируются, а не просто сохраняется ссылка на них. Это означает, что если мы отправим в очередь целое число, его значение будет фактически скопировано, и если мы изменим исходное значение после этого, проблем возникнуть не должно.</p>
<p>Тем не менее, при вызове функций с очередями следует ссылаться на данные через указатели (это особенно полезно, если сообщения для обмена большие).</p>
<p>Следует также учитывать, что при вставке в заполненную очередь или извлечении из пустой очереди могут выполняться блокирующие вызовы в течение заданного периода времени (этот период времени является параметром API).</p>
<p>В первом, ознакомительном, примере работа с очередью из 10 целых чисел показана только в основном цикле приложения loop, для того чтобы сосредоточиться на базовых вызовах API, которые нужно выполнять.</p>
<p>Для работы не требуется дополнительных библиотек. При подключении к IDE Arduino плат разработки для Esp32 операционная система FreeRTOS подключается автоматически вместе с библиотекой очередей - <strong><em>queue.h</em></strong>.</p>
<p>Таким образом, код начинается с объявления глобальной переменной типа QueueHandle_t, который нужен для ссылки на очередь FreeRTOS.</p>
<pre><code>QueueHandle_t queue;</code></pre>
<p>В первую очередь, в функции настройки открывается последовательный порт для вывода результатов приложения. Далее создаётся очередь с помощью вызова функции <strong><em>xQueueCreate</em></strong>. Эта функция принимает в качестве первого аргумента максимальное количество элементов, которые очередь может содержать, а в качестве второго аргумента — размер (в байтах) каждого элемента. <strong><em>Обратите внимание, что каждый элемент очереди должен иметь одинаковый размер</em></strong>.</p>
<p>В примере создается очередь, которая может содержать максимум 10 элементов (целых чисел), где размер каждого элемента указывается в байтах с помощью функции <strong><em>sizeof</em></strong>.</p>
<p>При успешном выполнении функция xQueueCreate вернёт дескриптор очереди, который имеет тип <strong><em>QueueHandle_t</em></strong>, как и переменная, которая объявлена глобально. В случае возникновения проблем с выделением очереди будет возвращён <strong><em>NULL</em></strong>. Таким образом, после проверки возвращённого результата функцией можно предупредить пользователя о возникновении проблемы.</p>
<pre><code>void setup() 
{
   Serial.begin(115200);
   queue = xQueueCreate(10, sizeof(int));
   if (queue == NULL)
   {
      Serial.println(&quot;Error creating the queue&quot;);
   }
}</code></pre>
<p>В начале основного цикла приложения определяется, создана ли очередь. Если все в порядке и очередь организована, то с помощью функции <strong><em>xQueueSend</em></strong> добавляются элементы в конец очереди для последующего использования.</p>
<p>Эта функция получает в качестве первого параметра дескриптор объявленной очереди. В качестве второго параметра она получает указатель на элемент, который следует вставить (хотя передаётся указатель, но в очередь копируется элемент), а в качестве последнего аргумента - максимальное время ожидания задачи в случае, если очередь заполнена.</p>
<p>Для последнего аргумента значение указывается в тиках (квантах FreeRTOS). Передача значения <strong><em>portMAX_DELAY</em></strong> означает, что ожидание будет продолжаться бесконечно, если очередь заполнена.</p>
<p>Поскольку очередь может содержать максимум 10 элементов, организуется простой цикл for и на каждой итерации вставляется текущее значение.</p>
<pre><code>for (int i = 0; i&lt;10; i++)
{
   xQueueSend(queue, &amp;i, portMAX_DELAY);
}</code></pre>
<p>Обратите внимание, что всегда <strong><em>передаётся указатель на одну и ту же переменную, но поскольку её фактическое значение будет скопировано</em></strong>, то нет никаких проблем с изменением её на новое значение на каждой итерации.</p>
<p>Аналогичный цикл используется для извлечения элементов очереди. Для того, чтобы обработать элемент, следует просто вызвать функцию <strong><em>xQueueReceive</em></strong>. Она получит в качестве первого параметра дескриптор очереди, в качестве второго параметра - указатель на буфер, в который будет скопирован полученный элемент, и, наконец, количество тиков для ожидания, если очередь пуста.</p>
<p>Как и прежде, в качестве первого аргумента передаётся глобальная переменная - дескриптор очереди, а в качестве последнего - значение <strong><em>portMAX_DELAY</em></strong>. Что касается буфера, в который копируется элемент, то перед использованием элемента объявляется переменная целочисленного типа, в которой сохраняется полученный элемент.</p>
<p>Следует заметить, что <strong><em>при выборке элемента он будет удалён из очереди</em></strong>. Если не требуется удалять элемент при извлечении, можно использовать функцию <strong><em>xQueuePeek</em></strong>.</p>
<p>В цикле обработки элементов их значения выводятся в последовательный порт.</p>
<pre><code>int element;
for (int i = 0; i&lt;10; i++)
{
   xQueueReceive(queue, &amp;element, portMAX_DELAY);
   Serial.print(element);
   Serial.print(&quot;|&quot;);
}</code></pre>
<p>В завершении цикла добавляется задержка между каждой итерацией основного цикла.</p>
<h3 id="пример-работы-с-очередью"><a href="QueueHandleOne/QueueHandleOne.ino">Пример работы с очередью</a></h3>
<h6 id="к-содержанию"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE">к содержанию</a></h6>
<hr />
<h3 id="xqueuecreate---cоздать-новую-очередь"><a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/01-xQueueCreate">xQueueCreate - cоздать новую очередь</a></h3>
<p>Функция <strong><em>xQueueCreate</em></strong> создаёт новую очередь и возвращает дескриптор, с помощью которого можно ссылаться на эту очередь.</p>
<pre><code> QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);</code></pre>
<p>Перед первым использованием очередей следует просмотреть заголовочный файл <strong><em>FreeRTOSConfig.h</em></strong>. Определение <strong><em>configSUPPORT_DYNAMIC_ALLOCATION</em></strong> должно быть установлено в 1 или не определено (в этом случае по умолчанию будет равно 1), чтобы эта функция RTOS API была доступна.</p>
<pre><code>#define configSUPPORT_DYNAMIC_ALLOCATION             1</code></pre>
<p>Для каждой очереди требуется оперативная память, которая используется для хранения состояния очереди и элементов, содержащихся в очереди (область хранения очереди). Если очередь создаётся с помощью <strong><em>xQueueCreate()</em></strong>, тогда необходимая оперативная память автоматически выделяется из кучи FreeRTOS.</p>
<p>Если очередь создаётся с помощью <strong><em>xQueueCreateStatic()</em></strong>, то оперативная память предоставляется разработчиком приложения, что приводит к увеличению количества параметров, но позволяет выделить оперативную память статически во время компиляции.</p>
<p>Параметры:</p>
<ul>
<li><strong><em>uxQueueLength</em></strong>, максимальное количество элементов, которое очередь может содержать одновременно;</li>
<li><strong><em>uxItemSize</em></strong>, размер в байтах, необходимый для хранения каждого элемента в очереди. Элементы добавляются в очередь копированием, а не по ссылке, поэтому это количество байт, которые будут скопированы для каждого элемента в очереди. Каждый элемент в очереди должен иметь одинаковый размер.</li>
</ul>
<p>Возврат:</p>
<p>если очередь создана успешно, то возвращается дескриптор созданной очереди. Если память, необходимая для создания очереди, не может быть выделена, то возвращается <strong><em>NULL</em></strong>.</p>
<pre><code>struct AMessage
{
   char ucMessageID;
   char ucData[20];
};

void vATask(void *pvParameters)
{
   QueueHandle_t xQueue1, xQueue2;
   // Создаём очередь, способную содержать до 10 чисел типа unsigned long
   xQueue1 = xQueueCreate(10, sizeof(unsigned long));
   if(xQueue1==NULL)
   {
      /* Очередь не была создана и не должна использоваться */
   }
   // Создаем очередь, способную содержать 10 структур, которые должны
   // быть помещены в очередь с помощью указателей, поскольку представляют
   // собой относительно большие данные
   xQueue2 = xQueueCreate(10, sizeof(struct AMessage));
   if( xQueue2 == NULL )
   {
      /* Очередь не была создана и не должна использоваться */
   }
   /* ... остальная часть кода задачи */
}
</code></pre>
<h6 id="к-содержанию-1"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE">к содержанию</a></h6>
<hr />
<h3 id="xqueuesend---поместить-элемент-в-очередь"><a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/03-xQueueSend">xQueueSend - поместить элемент в очередь</a></h3>
<p>Функция <strong><em>xQueueSend</em></strong> отправляет элемент в очередь. Хотя элемент, передаваемый в функцию, указывается как параметр по ссылке (через указатель) фактически в очередь укладывается копия элемента.</p>
<p>Эту функцию нельзя вызывать из подпрограммы обслуживания прерываний. Для этого используется функция <strong><em>xQueueSendFromISR()</em></strong>.</p>
<p>Формат:</p>
<pre><code>BaseType_t xQueueSend(QueueHandle_t xQueue,const void *pvItemToQueue,TickType_t xTicksToWait);</code></pre>
<p>По сути это макрос, который вызывает <strong><em>xQueueGenericSend()</em></strong>. Он включён для обратной совместимости с более ранними версиями FreeRTOS, в которых не было <strong><em>xQueueSendToFront()</em></strong> и <strong><em>xQueueSendToBack()</em></strong>.</p>
<p>Параметры:</p>
<ul>
<li><p><strong><em>xQueue</em></strong>, дескриптор очереди, в которой должен быть размещен элемент;</p></li>
<li><p><strong><em>pvItemToQueue</em></strong>, указатель на элемент, который необходимо поместить в очередь. Размер элементов, которые содержит очередь, должен быть определён при создании очереди, поэтому по указателю будет скопировано столько байт, каков указан размер элемента в хранилище очереди;</p></li>
<li><p><strong><em>xTicksToWait</em></strong>, максимальное время, в течение которого задача должна блокироваться в ожидании освобождения места в очереди, если она уже заполнена.</p></li>
</ul>
<p>Вызов функции будет повторен немедленно, если очередь заполнена, а значение параметра xTicksToWait равно 0.</p>
<p>Время определяется в тактовых периодах, поэтому для расчета реального времени блокировки в миллисекундах или в других единицах нужно использовать значение константа <strong><em>portTICK_PERIOD_MS</em></strong>.</p>
<p>Если для <strong><em>INCLUDE_vTaskSuspend</em></strong> во FreeRTOSConfig.h установлено значение «1» (это по умолчанию), а время блокировки указано как p<strong><em>ortMAX_DELAY</em></strong>, то это приведет к блокировке задачи на неопределенный срок (без истечения времени ожидания).</p>
<p>Возврат:</p>
<ul>
<li><strong><em>pdTRUE</em></strong>, если сообщение было успешно отправлено,</li>
<li><strong><em>errQUEUE_FULL</em></strong> в противном случае.</li>
</ul>
<p>Пример использования:</p>
<pre><code>struct AMessage
{
   char ucMessageID;
   char ucData[20];
 } xMessage;
 
unsigned long ulVar = 10UL;

void vATask(void *pvParameters)
{
   QueueHandle_t xQueue1, xQueue2;
   struct AMessage *pxMessage;
   
   // Создаём очередь, способную содержать 10 длинных целых без знака
   xQueue1 = xQueueCreate(10, sizeof(unsigned long));
   // Создаём очередь, способную содержать 10 указателей на структуры
   // сообщений. Они должны передаваться по указателю, поскольку содержат
   // длинные строки
   xQueue2 = xQueueCreate(10, sizeof(struct AMessage *));
   
   /* ... */
   
   if(xQueue1 != 0)
   {
      // Посылаем беззнаковые целые. Ждем 10 секунд, пока освободится 
      // место, при необходимости освобождаем его
      if (xQueueSend(xQueue1, (void *) &amp;ulVar, (TickType_t) 10) != pdPASS)
      {
         /* Не удалось отправить сообщение даже после 10 тиков */
      }
   }
   
   if (xQueue2 != 0)
   {
      // Отправляем указатель на структуру AMessage (не блокируем, если
      // очередь уже заполнена
      pxMessage = &amp; xMessage;
      xQueueSend(xQueue2, ( void *) &amp;pxMessage, (TickType_t) 0);
   }
   /* ... остальная часть кода задачи */
}</code></pre>
<h4 id="блокировка-при-записи-в-очередь">Блокировка при записи в очередь</h4>
<p>Как и при чтении из очереди, “записывающая” задача может быть заблокирована для ожидания возможности записи в очередь. Это происходит, когда очередь полностью заполнена и в ней нет свободного места для записи нового элемента данных. До тех пор пока какая-либо другая задача не прочитает данные из очереди, задача, которая пишет в очередь, будет «ожидать», находясь в заблокированном состоянии. В одну очередь могут писать сразу несколько задач, поэтому возможна ситуация, когда несколько задач находятся в блокированном состоянии, ожидая завершения операции записи в одну очередь. Когда в очереди появится свободное место, получит управление задача с наивысшим приоритетом. В случае если запись в очередь ожидали равноприоритетные задачи, управление получит та, которая находилась в блокированном состоянии дольше остальных.</p>
<p>Поэтому есть, как минимум, два варианта дальнейших действий в случае, если не удаётся поместить данные в очередь мгновенно (или за некоторое время для надежности): либо отказаться от этого, либо побыстрее выбрать данные из очереди.</p>
<h6 id="к-содержанию-2"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE">к содержанию</a></h6>
<hr />
<h3 id="xqueuereceive---выбрать-элемент-из-очереди"><a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/09-xQueueReceive">xQueueReceive - выбрать элемент из очереди</a></h3>
<p>Функция <strong><em>xQueueReceive</em></strong> извлекает элемент из очереди. Элемент получается путём копирования, поэтому необходимо предоставить буфер подходящего размера. Количество байт, скопированных в буфер, должно соответствовать значению, которое было определено при создании очереди.</p>
<p>Эту функцию нельзя использовать в подпрограмме обслуживания прерываний, альтернативой должно служить <strong><em>xQueueReceiveFromISR</em></strong>.</p>
<p>Формат:</p>
<pre><code>BaseType_t xQueueReceive(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait);</code></pre>
<p><strong><em>xQueueReceive</em></strong> - это макрос, который вызывает <strong><em>xQueueGenericReceive()</em></strong>.</p>
<p>Параметры:</p>
<ul>
<li><p><strong><em>xQueue</em></strong> - дескриптор очереди, из которой должен быть получен элемент;</p></li>
<li><p><strong><em>pvBuffer</em></strong> - указатель на буфер, в который будет скопирован полученный элемент;</p></li>
<li><p><strong><em>xTicksToWait</em></strong> - максимальное время, в течение которого задача должна блокироваться в ожидании поступления элемента, если очередь пуста на момент вызова. Если xTicksToWait установлен в 0, то при пустой очереди функция немедленно вернёт значение 0.</p></li>
</ul>
<p>Время ожидания определяется в тактовых периодах, поэтому для определения реального времени следует использовать в пересчете значение константы <strong><em>portTICK_PERIOD_MS</em></strong>.</p>
<p>Если для <strong><em>INCLUDE_vTaskSuspend</em></strong> установлено значение ‘1’ (а это по умолчанию), то время блокировки, указанное как <strong><em>portMAX_DELAY</em></strong> приведет к блокировке задачи на неопределенный срок (без истечения времени ожидания).</p>
<p>Возврат: <strong><em>pdTRUE</em></strong>, если элемент был успешно получен из очереди, в противном случае <strong><em>pdFALSE</em></strong>.</p>
<p>Пример использования:</p>
<pre><code>// Определяем переменную-структуру AMessage
struct AMessage
{
   char ucMessageID;
   char ucData[20];
}  xMessage;

// Определяем очередь, которая будет использоваться для отправки 
// и получения сообщений в виде структуры типа AMessage
QueueHandle_t xStructQueue = NULL;

// Определяем очередь, которая будет использоваться для отправки
// и получения указателей на структуры
QueueHandle_t xPointerQueue = NULL;

void vCreateQueues(void) 
{
   xMessage.ucMessageID = 0xab;
   memset(&amp;(xMessage.ucData), 0x12, 20);
   
   // Создаём очередь для отправки полных сообщений-структур. Ее также
   // можно создать и позже, но необходимо позаботиться о том, чтобы
   // очередь не использовалась до тех пор, пока она не будет создана
   xStructQueue  =  xQueueCreate(10, sizeof(xMessage));
   
   // Создаём очередь для отправки указателей на структуры AMessage
   xPointerQueue = xQueueCreate(10, sizeof(&amp;xMessage));
   
   if ((xStructQueue == NULL) || (xPointerQueue == NULL))
   {
      // &quot;Не удалось создать одну или несколько очередей из-за нехватки
      // доступной памяти в куче. Исправьте ошибку здесь. 
      // Очереди также могут быть созданы  статически
   }
}

// Задача, которая выполняет запись в очередь
void vATask(void *pvParameters)
{
   struct AMessage *pxPointerToxMessage;
   
   // Отправляем всю структуру в очередь, созданную для хранения 10 структур
   xQueueSend( 
      // Дескриптор очереди
      xStructQueue,
      // Адрес переменной xMessage  sizeof(struct AMessage), откуда
      // байты копируются в очередь
      (void *) &amp;xMessage,
      // Время блокировки, равное 0, означающее, что не нужно блокировать 
      // задачу, если очередь уже заполнена. Следует проверять значение,
      // возвращаемое функцией xQueueSend(), чтобы узнать, было ли
      // сообщение успешно отправлено в очередь
      (TickType_t  0)
   );
                             
   // Сохраняем адрес переменной xMessage в переменной-указателе
   pxPointerToxMessage = &amp;xMessage;
   
   // Отправляем адрес сообщения в очередь, созданную 
   // для хранения 10 указателей
   xQueueSend (xPointerQueue, (void *) &amp;pxPointerToxMessage,  (TickType_t) 0);
                
   /* ... некоторая часть кода */
}

// Задача, которая выполняет чтение из очереди
void vADifferentTask(void *pvParameters)
{
   struct AMessage xRxedStructure, *pxRxedPointer;
   if (xStructQueue != NULL)
   {
      // Получаем сообщение из созданной очереди для хранения сложного
      // структурного сообщения. Блокировка на 10 тиков, если сообщение
      // недоступно немедленно. Значение считывается в структурную
      // переменную AMessage, поэтому после вызова xQueueReceive()  
      // xRxedStructure будет содержать копию сообщения
      
      if (xQueueReceive(xStructQueue, &amp;(xRxedStructure), (TickType_t) 10) == pdPASS)
      {
         /* xRxedStructure теперь содержит копию xMessage. */
      }
   }
   
   if (xPointerQueue != NULL)
   {
      // Получаем сообщение из созданной очереди для хранения указателей.
      // Блокируем на 10 тиков, если сообщение недоступно - немедленно.
      // Значение считывается в переменную указателя, и полученное значение
      // является адресом сообщения. Переменная, после этого вызова
      // pxRxedPointer будет указывать на xMessage.
      
      if (xQueueReceive(xPointerQueue,  &amp;(pxRxedPointer), (TickType_t) 10) == pdPASS)
      {
         /* *pxRxedPointer теперь указывает на xMessage. */
      }
   }
   /* ... остальная часть кода задачи */
}  </code></pre>
<h4 id="блокировка-задачи-при-чтении-из-очереди">Блокировка задачи при чтении из очереди</h4>
<p>Когда какая-либо задача пытается прочитать данные из очереди, которая не содержит ни одного элемента, то задача приостанавливается – то есть переходит в блокированное состояние. Приостановленная задача вернется в состояние готовности к выполнению, когда другая задача (или прерывание) поместит данные в очередь. После этого планировщик сможет передать управление ожидающей задаче (но если нет задач с более высоким приоритетом).</p>
<p>Выход из блокированного состояния возможен также при истечении заданного тайм-аута, даже если очередь на протяжении всего этого времени оставалась пуста. Данные из очереди могут читать сразу несколько задач. Когда очередь пуста, то все они находятся в блокированном состоянии. Когда в очереди появляется элемент данных, начнет выполняться та задача, которая имеет наибольший приоритет. Возможна ситуация, когда равноприоритетные задачи ожидают появления данных в очереди. В этом случае при поступлении данных в очередь управление получит та задача, время ожидания которой было наибольшим. Остальные же останутся в блокированном состоянии.</p>
<p>Таймаут чтения из очереди позволяет реализовать механизм формирования интервалов вместо использования vTaskDelay(). В этом случае разблокировка задачи произойдет в двух случаях – либо появятся новые данные в очереди, либо истечет заданный таймаут, в зависимости от того, что наступит ранее. Таймаут можно задать равным нулю, тогда задача чтения вообще не будет блокироваться.</p>
<h6 id="к-содержанию-3"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE">к содержанию</a></h6>
<hr />
<h3 id="xqueuesendfromisr---xqueuereceivefromisr"><a href="#">xQueueSendFromISR - xQueueReceiveFromISR</a></h3>
<p>В программах обслуживания прерываний для отправки в очередь и выборки сообщений из очереди используется функции <strong><em>xQueueSendFromISR()</em></strong> и <strong><em>xQueueReceiveFromISR()</em></strong>.</p>
<p>Эти функции очень похожи на обычные версии - xQueueSend и xQueueReceive, но имеются некоторые отличия:</p>
<p>отсутствует аргумент xTicksToWait – поскольку выполнение обработчиков прерываний должно занимать как можно меньше времени, поэтому ни о каких ожиданиях внутри прерываний и речи быть не может.</p>
<p>Появился новый аргумент <strong><em>pxHigherPriorityTaskWoken</em></strong>. Функция может вернуть в данном аргументе два состояния - <strong><em>pdTRUE</em></strong> или <strong><em>pdFALSE</em></strong>. Если вернулось pdTRUE, то это указывает, что необходимо досрочно отдать управление планировщику задач FreeRTOS. Допустим, в текущий момент выполняется задача с низким приоритетом, а высокоприоритетная ожидает сообщения из очереди и приостановлена. Далее происходит прерывание, из которого отправляется какое-либо сообщение в очередь. Но по окончании работы обработчика прерываний выполнение возвращается к текущей низкоприоритетной задаче, а высокоприоритетная все ещё ожидает, пока закончится текущий квант времени, и очередь всё ещё не обрабатывается. Однако если после этого передать управление планировщику досрочно через <strong><em>portYIELD_FROM_ISR</em></strong>, то он передаст управление ожидающей высокоприоритетной задаче. Это позволяет значительно сократить время реакции системы на прерывание.</p>
<h3 id="передача-сообщения-из-задачи-и-прерывания-с-приемом-в-основном-цикле"><a href="QueueHandlMulti2/QueueHandlMulti2.ino">Передача сообщения из задачи и прерывания с приемом в основном цикле</a></h3>
<p>В этом примере строится очередь для хранения структур в двумя полями: первое - это строка с, максимум, 256 символами; второе количество байт с символами в строке. Прерывание вызывается по таймеру и отправляет сообщение в очередь с указанием времени в миллисекундах с момента запуска приложения. Также в приложении периодически запускается задача, которая отправляет сообщение в очередь с указанием количества раз запуска задачи. Все сообщения принимаются в основном цикле и передаются в последовательный порт.</p>
<p>Ниже представлен протокол работы приложения:</p>
<pre><code>TASK: Очередь для структур не создана!
SETUP: Очередь сформирована!
LOOP: Не удалось принять структуру даже после 10 тиков!
LOOP: Не удалось принять структуру даже после 10 тиков!
40: Прошло 1893 миллисекунд
55: Передано 2 сообщение из задачи
40: Прошло 3293 миллисекунд
55: Передано 3 сообщение из задачи
40: Прошло 4693 миллисекунд
55: Передано 4 сообщение из задачи
40: Прошло 6093 миллисекунд
55: Передано 5 сообщение из задачи
40: Прошло 7493 миллисекунд
55: Передано 6 сообщение из задачи
40: Прошло 8893 миллисекунд
ISR: Не удалось отправить структуру!
55: Передано 7 сообщение из задачи
ISR: Не удалось отправить структуру!
41: Прошло 10293 миллисекунд
41: Прошло 11693 миллисекунд
TASK: Не удалось отправить структуру даже после 5 тиков!
55: Передано 8 сообщение из задачи
41: Прошло 13093 миллисекунд
TASK: Не удалось отправить структуру даже после 5 тиков!
55: Передано 9 сообщение из задачи
TASK: Не удалось отправить структуру даже после 5 тиков!
41: Прошло 14493 миллисекунд
TASK: Не удалось отправить структуру даже после 5 тиков!
56: Передано 10 сообщение из задачи
TASK: Не удалось отправить структуру даже после 5 тиков!
41: Прошло 15893 миллисекунд
56: Передано 11 сообщение из задачи
ISR: Не удалось отправить структуру!
56: Передано 12 сообщение из задачи
ISR: Не удалось отправить структуру!
56: Передано 13 сообщение из задачи
ISR: Не удалось отправить структуру!
41: Прошло 20093 миллисекунд
TASK: Не удалось отправить структуру даже после 5 тиков!
41: Прошло 21493 миллисекунд
41: Прошло 22893 миллисекунд
...</code></pre>
<h3 id="библиография">Библиография</h3>
<h4 id="queue-management"><a href="https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/00-QueueManagement">Queue Management</a></h4>
<h4 id="freertos-queues"><a href="https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/02-Queues-mutexes-and-semaphores/01-Queues">FreeRTOS queues</a></h4>
<h4 id="очереди-freertos"><a href="https://kotyara12.ru/iot/esp32_queue/">Очереди FreeRTOS</a></h4>
<h4 id="esp32-arduino-freertos-queues"><a href="https://techtutorialsx.com/2017/08/20/esp32-arduino-freertos-queues/">ESP32 Arduino: FreeRTOS Queues</a></h4>
<h6 id="к-содержанию-4"><a href="#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE">к содержанию</a></h6>
</body>
</html>
