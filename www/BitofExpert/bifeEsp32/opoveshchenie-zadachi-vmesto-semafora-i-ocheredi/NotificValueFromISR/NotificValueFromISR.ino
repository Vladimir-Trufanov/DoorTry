/** Arduino-Esp32-CAM                           *** NotificValueFromISR.ino ***
 * 
 *               Использовать уведомления для отправки значения из ISR в задачу
 * 
 * v1.0.0, 09.02.2025                                 Автор:      Труфанов В.Е.
 * Copyright © 2025 tve                               Дата создания: 09.02.2025
 * 
**/

// Определяем заголовок для объекта таймерного прерывания
hw_timer_t *timer = NULL;
// Определяем заголовок задачи, играющей роль блокированных действий. Это 
// пример функции передачи в универсальном периферийном драйвере. Задача RTOS 
// вызовет функцию оповещения, а затем будет ожидать его в заблокированном 
// состоянии (чтобы не использовать процессорное время) до тех пор, пока не 
// будет получено уведомление о завершении передачи. Передача осуществляется с
// помощью DMA и в завершении прерывания также DMA используется для отправки 
// уведомления задаче
static TaskHandle_t xHandlingTask = NULL;  

// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);
   // Определяем задачу
   xTaskCreatePinnedToCore (
      vNotifiedTask,   // название функции, которая будет запускаться, как задача
      "Сообщение",     // название задачи
      1024,            // размер стека в байтах
      NULL,            // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      0,               // приоритет задачи
      &xHandlingTask,  // дескриптор (указатель или заголовок) на задачу
      0                // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 3 секунды (3000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 3000000, true, 0);
   Serial.println("SETUP отработал!");
}
// ****************************************************************************
// *           Отправить уведомление cо значением задаче из прерывания        *
// ****************************************************************************
int i=0; // счётчик прерываний
void ARDUINO_ISR_ATTR onTimer() 
{
   // Резервируем переменную для значения
   uint32_t ulStatusRegister;
   // Резервируем регистратор приоритета разблокированной задачи
   BaseType_t xHigherPriorityTaskWoken;
   i++;
   Serial.print("Прерывание сработало "); Serial.print(i); Serial.println(" раз");
   // Готовим значение для передачи с оповещением
   ulStatusRegister = i;
   // Инициализируем xHigherPriorityTaskWoken значением false. При вызове
   // функция xTaskNotifyFromISR() разблокирует задачу обработки, и если приоритет
   // задачи обработки выше приоритета текущей запущенной задачи, то для функции 
   // xHigherPriorityTaskWoken автоматически будет установлено значение pdTRUE
   xHigherPriorityTaskWoken = pdFALSE;
   // Передаём сообщение в задачу обработки от прерывания. xHandlingTask - это дескриптор задачи,
   // который был получен когда задача была создана
   //xTaskNotifyIndexedFromISR(xHandlingTask,2,ulStatusRegister,eSetValueWithOverwrite,&xHigherPriorityTaskWoken);
   xTaskNotifyFromISR(xHandlingTask,ulStatusRegister,eSetValueWithOverwrite,&xHigherPriorityTaskWoken);
   // Принудительно переключаеме контекст на задачу xHandlingTask, так как теперь xHigherPriorityTaskWoken = pdTRUE
   portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}  
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   delay(1300);
}
// ****************************************************************************
// * Задача, которая блокируется на уведомлении. Если бы задача блокировалась *
// * на семафоре, она бы вызывала функцию API xSemaphoreTake(), но поскольку  *
// *   задача использует уведомление, она вместо этого вызывает функцию API   *
// *     ulTaskNotifyTake(). Функция ulTaskNotifyTake() всегда использует     *
// *     уведомление с индексом 0. Чтобы использовать уведомление с любым     *
// *            конкретным индексом массива, используйте функцию              *
// *           ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake()            *
// ****************************************************************************
static void vNotifiedTask(void *pvParameters)  
{  
   uint32_t ulInterruptStatus;
   for( ;; )  
   { 
      // Ждём получения уведомления, которое будет отправлено непосредственно в эту задачу.   
      xTaskNotifyWait ( 
         0,              
         0,       
         &ulInterruptStatus, // для приёма значения из прерывания
         portMAX_DELAY       // блокировка до приема на неопределённый срок
      );
      // Выполняем обработку уведомления                       
      DoSomething(ulInterruptStatus);
   }  
}  
// ****************************************************************************
// *            Обрабатываем событие, заблокированное уведомлением            *
// ****************************************************************************
void DoSomething(uint32_t value) 
{
   Serial.print("Задача получила уведомление со значением: ");
   Serial.println(value);
}

// ************************************************ NotificValueFromISR.ino ***
