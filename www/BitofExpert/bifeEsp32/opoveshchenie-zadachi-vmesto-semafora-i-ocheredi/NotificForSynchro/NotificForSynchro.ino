/** Arduino-Esp32-CAM                             *** NotificForSynchro.ino ***
 * 
 *              Использовать уведомления для синхронизации прерывания с задачей
 *                   и выполнения некоторой обработки в блокированном состоянии
 * 
 * v1.0.1, 09.02.2025                                 Автор:      Труфанов В.Е.
 * Copyright © 2025 tve                               Дата создания: 08.02.2025
 * 
 * SETUP отработал!
 * Задача запустилась 1 раз
 * Задача получила уведомление!
 * Задача запустилась 2 раз
 * Задача получила уведомление!
 * Задача запустилась 3 раз
 * Задача получила уведомление!
 * ...
**/

// Определяем заголовок для объекта таймерного прерывания
hw_timer_t *timer = NULL;
// Определяем заголовок задачи, играющей роль блокированных действий. Это 
// пример функции передачи в универсальном периферийном драйвере. Задача RTOS 
// вызовет функцию оповещения, а затем будет ожидать его в заблокированном 
// состоянии (чтобы не использовать процессорное время) до тех пор, пока не 
// будет получено уведомление о завершении передачи. Передача осуществляется с
// помощью DMA и в завершении прерывания также DMA используется для отправки 
// уведомления задаче
static TaskHandle_t xTaskToNotify = NULL;  
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);
   // Определяем задачу
   xTaskCreatePinnedToCore (
      vNotifiedTask,   // название функции, которая будет запускаться, как задача
      "Сообщение",     // название задачи
      1024,            // размер стека в байтах
      NULL,            // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      0,               // приоритет задачи
      &xTaskToNotify,  // дескриптор (указатель или заголовок) на задачу
      0                // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 3 секунды (3000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 3000000, true, 0);
   Serial.println("SETUP отработал!");
}
// ****************************************************************************
// *                 Отправить уведомление задаче из прерывания               *
// ****************************************************************************
void ARDUINO_ISR_ATTR onTimer() 
{
   // Параметр xHigherPriorityTaskWoken инициализируем значением pdFALSE, 
   // поскольку он будет установлен в значение pdTRUE внутри прерывания с 
   // помощью функции API. Ситуация будет безопасной для прерывания, если вызов 
   // функции API разблокирует задачу, имеющую более высокий приоритет, чем 
   // задача, которую прервала эта ISR
   BaseType_t xHigherPriorityTaskWoken;  
   xHigherPriorityTaskWoken = pdFALSE;  
   // Отправляем уведомление непосредственно задаче, которая выполняет
   // некоторую обработку, связанную с этим прерыванием. В первом параметре 
   // указываем дескриптор задачи, которой отправляется уведомление
   vTaskNotifyGiveFromISR(xTaskToNotify, &xHigherPriorityTaskWoken);
   // Так как xHigherPriorityTaskWoken теперь pdTRUE, то вызов 
   // portYIELD_FROM_ISR() приведет к переключению контекста и это прерывание 
   // вернется непосредственно к разблокированной задаче
   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);  
}  
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   delay(1300);
}
// ****************************************************************************
// * Задача, которая блокируется на уведомлении. Если бы задача блокировалась *
// * на семафоре, она бы вызывала функцию API xSemaphoreTake(), но поскольку  *
// *   задача использует уведомление, она вместо этого вызывает функцию API   *
// *     ulTaskNotifyTake(). Функция ulTaskNotifyTake() всегда использует     *
// *     уведомление с индексом 0. Чтобы использовать уведомление с любым     *
// *            конкретным индексом массива, используйте функцию              *
// *           ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake()            *
// ****************************************************************************
int i=0;
static void vNotifiedTask(void *pvParameters)  
{  
   for( ;; )  
   {  
      i++;
      Serial.print("Задача запустилась "); Serial.print(i); Serial.println(" раз");
      // Ждём получения уведомления, которое будет отправлено непосредственно в эту задачу.   
      // Для первого параметра задано значение false, что позволяет выполнить 
      // вызов, повторяющий поведение счетного семафора. Следует установить для 
      // параметра значение true для воспроизведения поведения двоичного семафора   
      // Второму параметру присвоено значение port MAX_DELAY, что заставляет задачу 
      // блокироваться на неопределенный срок в ожидании уведомления. 
      // Это сделано для упрощения примера, реальные приложения не должны 
      // блокироваться на неопределенный срок, поскольку это не даёт задаче   
      // восстанавливается после ошибок.
      if (ulTaskNotifyTake(pdFALSE, portMAX_DELAY) != 0)  
      {  
         // Обрабатываем заданное событие, как только задача получит уведомление 
         DoSomething();  
      }  
   }  
}  
// ****************************************************************************
// *            Обрабатываем событие, заблокированное уведомлением            *
// ****************************************************************************
void DoSomething() 
{
   Serial.println("Задача получила уведомление!");
}

// ************************************************** NotificForSynchro.ino ***
