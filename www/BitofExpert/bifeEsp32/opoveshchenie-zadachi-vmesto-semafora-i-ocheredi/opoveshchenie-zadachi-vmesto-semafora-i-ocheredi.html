<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="оповещение-задачи-вместо-семафора-и-очереди-2025-02-09"><a href="https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/opoveshchenie-zadachi-vmesto-semafora-i-ocheredi/opoveshchenie-zadachi-vmesto-semafora-i-ocheredi.md">Оповещение задачи вместо семафора и очереди</a> [2025-02-09]</h2>
<p>Очереди и семафоры - это базовые функции, предоставляемые всеми операционными системами. Разработчики, впервые использующие FreeRTOS, применяют их, потому что они им знакомы. Однако в большинстве случаев <strong><em>прямые уведомления о задачах FreeRTOS</em></strong> обеспечивают более компактную и на 45% более быструю альтернативу семафорам, а <strong><em>буферы сообщений и потоковые буферы FreeRTOS</em></strong> обеспечивают более компактную и быструю альтернативу очередям.</p>
<blockquote>
<p>Ричард Барри основал проект FreeRTOS в 2003 году, более десяти лет занимался разработкой и продвижением FreeRTOS в своей компании Real Time Engineers Ltd, а сейчас продолжает работать над FreeRTOS в составе большой команды в качестве главного инженера в Amazon Web Services.</p>
</blockquote>
<h3 id="предыстория-oт-ричарда-барри"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%BE%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">Предыстория oт Ричарда Барри</a></h3>
<h3 id="как-узнать-версию-freertоs"><a href="#%D0%BA%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8E-freertos">Как узнать версию FreeRTОS</a></h3>
<h3 id="семафорные-функции-чeрез-уведомления"><a href="#%D1%81%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%B2%D0%B5%D0%B4%D0%BE%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Семафорные функции чeрез уведомления</a></h3>
<h3 id="пример-использования-уведомления-для-синхрoнизации-прерывания-с-задачей"><a href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%83%D0%B2%D0%B5%D0%B4%D0%BE%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5%D0%B9">Пример использования уведомления для синхрoнизации прерывания с задачей</a></h3>
<h3 id="функции-с-передачей-величин-uint32_t-через-уведомления"><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D1%81-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B5%D0%B9-%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD-uint32t-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%B2%D0%B5%D0%B4%D0%BE%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Функции с передачей величин uint32_t через уведомления</a></h3>
<h3 id="пример-испoльзования-уведомления-для-отправки-значения-из-isr-в-задачу"><a href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%83%D0%B2%D0%B5%D0%B4%D0%BE%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BB%D1%8F-%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%B7-isr-%D0%B2-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D1%83">Пример испoльзования уведомления для отправки значения из ISR в задачу</a></h3>
<p>Каждая задача RTOS имеет массив уведомлений о задачах. Каждое уведомление о задаче может находиться в одном из двух состояний: “ожидание” или “не ожидание”, а также имеет 32-битное значение уведомления. Константа <strong><em>configTASK_NOTIFICATION_ARRAY_ENTRIES</em></strong> в файле конфигурации FreeRTOS <strong><em>FreeRTOSConfig.h</em></strong> устанавливает количество индексов в массиве уведомлений о задачах. До версии FreeRTOS V10.4.0 задачи имели только одно уведомление, а не массив уведомлений.</p>
<blockquote>
<p>Оповещения задач осуществляются через <strong><em>DMA</em></strong> следующим образом: задача RTOS вызывает передающую функцию, затем ждёт в блокированном состоянии (не потребляя время CPU), пока не получит оповещение о завершении передачи. Передача происходит под управлением DMA, а прерывание завершения DMA используется для оповещения задачи.</p>
</blockquote>
<blockquote>
<p>Для отправки оповещений используются API-вызовы группы <strong><em>TaskNotify</em></strong> или <strong><em>TaskNotifyGive</em></strong>. Оповещения остаются в состоянии ожидания, пока принимающая задача не вызовет их по <strong><em>TaskNotifyWait</em></strong> или <strong><em>TaskNotifyTake</em></strong>.</p>
</blockquote>
<p>Прямое уведомление о задаче — это событие, отправляемое непосредственно задаче, а не косвенно через промежуточный объект, такой как очередь, группа событий или семафор. При отправке прямого уведомления о задаче состояние уведомления в принимающей задаче устанавливается в «ожидание». Точно так же, как задача может блокироваться на промежуточном объекте, таком как семафор, в ожидании доступности этого семафора, задача может блокироваться на уведомлении о задаче в ожидании перехода этого уведомления в состояние ожидания.</p>
<p>При отправке прямого уведомления о задаче в задачу можно дополнительно обновить его значение на приёме одним из следующих способов:</p>
<ul>
<li><p>перезаписать значение независимо от того, прочитало ли его получающее задание;</p></li>
<li><p>перезаписать значение, но только если получающая задача прочитала перезаписываемое значение;</p></li>
<li><p>установить один или несколько битов в значении;</p></li>
<li><p>увеличить (добавить единицу) значение.</p></li>
</ul>
<p>Вызов <strong><em>xTaskNotifyWait()/xTaskNotifyWaitIndexed()</em></strong> для считывания значения уведомления приводит к тому, что состояние уведомления становится равным <strong><em>не ожидающее</em></strong>. Состояние уведомления также можно явно установить равным <strong><em>не ожидающее</em></strong> с помощью вызова <strong><em>xTaskNotifyStateClear()/xTaskNotifyStateClearIndexed()</em></strong>.</p>
<p>Примечание: каждое уведомление в массиве работает независимо - задача может быть заблокирована только одним уведомлением в массиве за раз и не будет разблокирована уведомлением, отправленным в любой другой индекс массива.</p>
<p>Функция уведомлений о задачах RTOS включена по умолчанию и может быть исключена из сборки (для экономии 5 байт на индекс массива для каждой задачи) путем установки <strong><em>configUSE_TASK_NOTIFICATIONS</em></strong> в значение <strong><em>0</em></strong> в <strong><em>FreeRTOSConfig.h</em></strong>.</p>
<blockquote>
<p>ВАЖНОЕ ПРИМЕЧАНИЕ: для буферов потоков и сообщений FreeRTOS использует уведомление о задаче по индексу массива 0. Если требуется сохранить состояние уведомления о задаче при вызове функции API буфера потока или сообщения, следует использовать уведомление о задаче по индексу массива больше 0.</p>
</blockquote>
<p>Гибкость уведомлений о задачах позволяет использовать их там, где в противном случае пришлось бы создавать отдельную очередь, двоичный семафор, счетный семафор или группу событий. Разблокировка задачи RTOS с помощью прямого уведомления выполняется на 45% быстрее и требует меньше оперативной памяти, чем разблокировка задачи с помощью промежуточного объекта.</p>
<p>Как и следовало ожидать, эти преимущества в производительности требуют некоторых ограничений в использовании:</p>
<p>уведомления о задачах RTOS можно использовать только в том случае, если существует только одна задача, которая может быть получателем события. Однако это условие выполняется в большинстве реальных случаев использования, например, при прерывании, разблокирующем задачу, которая будет обрабатывать данные, полученные в результате прерывания.</p>
<h6 id="к-содержанию"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="предыстория-от-ричарда-барри">Предыстория от Ричарда Барри</h3>
<p>“<em>В FreeRTOS, выпущенной в 2002 году, была добавлена функция семафоров за счёт реализации API семафоров в виде набора макросов, которые вызывают API очередей. Преимущество такого подхода заключалось в том, что функция семафоров была добавлена без увеличения размера кода (что было важно, когда объём флэш-памяти обычно был меньше, чем сегодня), но недостатком было то, что семафоры были нетипично тяжёлыми объектами, поскольку они наследовали все функции очереди</em>.</p>
<p><em>Например, очереди по-настоящему учитывают потоки и приоритеты, включают в себя механизм событий и упорядоченные по приоритету списки задач, ожидающих отправки в очередь и получения из очереди. В некоторых случаях использования семафоров эта комплексная функциональность полезна, но в большинстве случаев она не требуется</em>.</p>
<p><em>Поэтому, когда мы искали простой механизм событий для использования в библиотеках драйверов, мы решили не переписывать код семафоров, а создать новый примитив, специально предназначенный для этих наиболее распространённых случаев использования. Этот примитив</em> - <strong><em>прямые уведомления о задачах</em></strong> - <em>с этого момента будет называться просто <strong>уведомления</strong></em>“.</p>
<h4 id="что-такое-непосредственное-уведомления-о-задаче">Что такое непосредственное уведомления о задаче?</h4>
<p>Большинство методов межзадачной связи проходят через промежуточные объекты, такие как <strong><em>очередь, семафор или группа событий</em></strong>. Отправляющая задача записывает данные в объект связи, а принимающая задача считывает данные из объекта связи. При использовании прямого уведомления о задаче, как следует из названия, отправляющая задача отправляет уведомление непосредственно принимающей задаче без использования промежуточного объекта.</p>
<figure>
<img src="kommunikaciya-cherez-obekt-posrednik.jpg" alt="Коммуникация через объект-посредник" /><figcaption>Коммуникация через объект-посредник</figcaption>
</figure>
<figure>
<img src="obshchenie-bez-posrednicheskogo-obekta.jpg" alt="Общение без посреднического объекта" /><figcaption>Общение без посреднического объекта</figcaption>
</figure>
<p>Начиная с FreeRTOS V10.4.0, каждая задача имеет массив уведомлений. До этого у каждой задачи было по одному уведомлению. Каждое уведомление состоит из 32-битного значения и логического состояния, которые вместе занимают всего 5 байт оперативной памяти.</p>
<p>Точно так же, как задача может блокироваться на двоичном семафоре в ожидании, пока этот семафор станет «доступным», задача может блокироваться на уведомлении в ожидании, пока состояние этого уведомления «ожидающее». Точно так же, как задача может блокироваться на счётном семафоре в ожидании, пока счёт этого семафора ненулевой, задача может блокироваться на уведомлении в ожидании, пока значение этого уведомления ненулевое.</p>
<h6 id="к-содержанию-1"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="как-узнать-версию-freertos">Как узнать версию FreeRTOS</h3>
<p>Узнать версию FreeRTOS можно по определениям, доступным в файле <strong><em>task.h</em></strong>. Они определяют версию ядра по следующим параметрам: tskKERNEL_VERSION_NUMBER (версия ядра), tskKERNEL_VERSION_MAJOR (основная версия), tskKERNEL_VERSION_MINOR (минорная версия), tskKERNEL_VERSION_BUILD (версия сборки).</p>
<pre><code>#include &quot;task.h&quot;

/*-----------------------------------------------------------
 * MACROS AND DEFINITIONS
 *----------------------------------------------------------*/

#define tskKERNEL_VERSION_NUMBER       &quot;V10.4.3&quot;
#define tskKERNEL_VERSION_MAJOR        10
#define tskKERNEL_VERSION_MINOR        4
#define tskKERNEL_VERSION_BUILD        3</code></pre>
<h6 id="к-содержанию-2"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="семафорные-функции-через-уведомления">Семафорные функции через уведомления</h3>
<h4 id="xtasknotifygive-xtasknotifygiveindexed">xTaskNotifyGive, xTaskNotifyGiveIndexed</h4>
<p>task.h</p>
<pre><code>BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify);

BaseType_t xTaskNotifyGiveIndexed(TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify);</code></pre>
<p><strong><em>xTaskNotifyGive()</em></strong> - это макрос, когда уведомление о задаче используется в качестве облегченной и более быстрой альтернативы двоичному коду или счетному семафору. Семафоры FreeRTOS задаются с помощью API-функции xSemaphoreGive(). xTaskNotifyGive() - это эквивалент, который использует одно из значений уведомления принимающей задачи RTOS вместо семафора.</p>
<p>xTaskNotifyGive() и xTaskNotifyGiveIndexed() - это эквивалентные макросы. Разница лишь в том, что xTaskNotifyGiveIndexed() может работать с любым уведомлением о задаче в массиве, а xTaskNotifyGive() всегда работает с уведомлением о задаче по индексу 0 в массиве.</p>
<p>Если значение уведомления о задаче используется в качестве эквивалента двоичного или счётного семафора, то задача, получающая уведомление, должна ожидать уведомления с помощью функции <strong><em>ulTaskNotifyTake()</em></strong> API.</p>
<p>Примечание: каждое уведомление в массиве работает независимо - задача может быть заблокирована только одним уведомлением в массиве и не будет разблокирована уведомлением, отправленным в любой другой индекс массива.</p>
<p>Функция xTaskNotifyGive() не должна вызываться из подпрограммы обработки прерываний. Вместо этого используйте <strong><em>vTaskNotifyGiveFromISR()</em></strong>.</p>
<p>configUSE_TASK_NOTIFICATIONS должно быть равно 1 в FreeRTOSConfig.h (или не определён), чтобы эти макросы были доступны. Константа configTASK_NOTIFICATION_ARRAY_ENTRIES задает количество индексов в массиве уведомлений каждой задачи.</p>
<p>До FreeRTOS V10.4.0 у каждой задачи было одно «значение уведомления», и все функции API уведомлений задач работали с этим значением. Замена одного значения уведомления массивом значений уведомлений потребовала создания нового набора функций API, которые могли бы обращаться к конкретным уведомлениям в массиве. xTaskNotifyGive() — это исходная функция API, которая остаётся обратно совместимой, всегда работая со значением уведомления по индексу 0 в массиве. Вызов xTaskNotifyGive() эквивалентен вызову xTaskNotifyGiveIndexed() с параметром uxIndexToNotify, равным 0.</p>
<p><strong><em>Параметры:</em></strong></p>
<ul>
<li><p><strong><em>xTaskToNotify</em></strong>, дескриптор (заголовок) задачи, получающей уведомления. Данный дескриптор определяется при создании задачи с помощью xTaskCreate() параметром pxCreatedTask или возвращается при создании задачи с помощью xTaskCreateStatic(). Также заголовок может быть получен при вызове xTaskGetHandle(). Обработчик выполняемой в данный момент задачи RTOS возвращается функцией <strong><em>xTaskGetCurrentTaskHandle()</em></strong> API;</p></li>
<li><p><strong><em>uxIndexToNotify</em></strong>, индекс в массиве значений уведомлений целевой задачи, на который должно быть отправлено уведомление. uxIndexToNotify должен быть меньше, чем configTASK_NOTIFICATION_ARRAY_ENTRIES. Функция xTaskNotifyGive() не имеет этого параметра и всегда отправляет уведомления на индекс 0.</p></li>
</ul>
<h4 id="vtasknotifygivefromisr-vtasknotifygiveindexedfromisr">vTaskNotifyGiveFromISR, vTaskNotifyGiveIndexedFromISR</h4>
<p>task.h</p>
<pre><code>void vTaskNotifyGiveFromISR(
   TaskHandle_t xTaskToNotify, 
   BaseType_t *pxHigherPriorityTaskWoken);

void vTaskNotifyGiveIndexedFromISR(
   TaskHandle_t xTaskHandle, 
   UBaseType_t uxIndexToNotify,
   BaseType_t *pxHigherPriorityTaskWoken);</code></pre>
<p>Это версии xTaskNotifyGive() и xTaskNotifyGiveIndexed(), которые нужно использовать из подпрограмм обслуживания прерываний (ISR).</p>
<p><strong><em>Параметры:</em></strong></p>
<ul>
<li><p><strong><em>xTaskToNotify</em></strong>, дескриптор (заголовок) задачи, получающей уведомления. Данный дескриптор определяется при создании задачи с помощью xTaskCreate() параметром pxCreatedTask или возвращается при создании задачи с помощью xTaskCreateStatic(). Также заголовок может быть получен при вызове xTaskGetHandle(). Обработчик выполняемой в данный момент задачи RTOS возвращается функцией <strong><em>xTaskGetCurrentTaskHandle()</em></strong> API;</p></li>
<li><p><strong><em>uxIndexToNotify</em></strong>, индекс в массиве значений уведомлений целевой задачи, на который должно быть отправлено уведомление. uxIndexToNotify должен быть меньше, чем configTASK_NOTIFICATION_ARRAY_ENTRIES. Функция vTaskNotifyGiveFromISR() не имеет этого параметра и всегда отправляет уведомления на индекс 0;</p></li>
<li><p><strong><em>pxHigherPriorityTaskWoken</em></strong>: <em>pxHigherPriorityTaskWoken должен быть инициализирован pdFALSE. vTaskNotifyGiveFromISR() установит </em>pxHigherPriorityTaskWoken в значение pdTRUE, если отправка уведомления привела к разблокировке задачи, а у разблокированной задачи приоритет выше, чем у текущей запущенной задачи. Если vTaskNotifyGiveFromISR() устанавливает это значение в pdTRUE, то после этого перед завершением прерывания следует запросить переключение контекста - portYIELD_FROM_ISR(xHigherPriorityTaskWoken. pxHigherPriorityTaskWoken является необязательным параметром и может иметь значение NULL.</p></li>
</ul>
<h4 id="ultasknotifytake-ultasknotifytakeindexed">ulTaskNotifyTake, ulTaskNotifyTakeIndexed</h4>
<p>task.h</p>
<pre><code>uint32_t ulTaskNotifyTake( 
   BaseType_t xClearCountOnExit,
   TickType_t xTicksToWait
);
   
uint32_t ulTaskNotifyTakeIndexed(
   UBaseType_t uxIndexToWaitOn, 
   BaseType_t xClearCountOnExit,
   TickType_t xTicksToWait 
);</code></pre>
<p>Значение уведомления, напрямую поступающее в задачу может быть изменено принимающей задачей несколькими различными способами. Например, уведомление может перезаписать одно из значений или просто установить один или несколько битов в одном из значений уведомления в принимающей задаче.</p>
<p><strong><em>ulTaskNotifyTake()</em></strong> является макросом, предназначенным для использования в качестве более быстрой и легковесной альтернативы двоичному коду или счетному семафору. Семафоры FreeRTOS берутся с помощью xSemaphoreTake(). Функция API ulTaskNotifyTake() это эквивалент, который использует значение уведомления вместо семафора.</p>
<p>ulTaskNotifyTake() и ulTaskNotifyTakeIndexed() являются эквивалентными макросами - с той лишь разницей, что ulTaskNotifyTakeIndexed() может работать с любым уведомлением о задаче внутри массива, а ulTaskNotifyTake() всегда работает с уведомлением о задаче с индексом массива 0.</p>
<p>Когда задача использует значение уведомления в качестве двоичного или счётного семафора, другие задачи и прерывания должны отправлять ей уведомления с помощью макроса xTaskNotifyGive() или функции <strong><em>xTaskNotify()</em></strong> с параметром <strong><em>eAction</em></strong>, установленным в <strong><em>eIncrement</em></strong> (эти два варианта эквивалентны).</p>
<p>ulTaskNotifyTake() может либо обнулить значение уведомления задачи при выходе, и в этом случае значение уведомления действует как двоичный семафор, либо уменьшить значение уведомления задачи при выходе, и в этом случае значение уведомления действует больше как счетный семафор.</p>
<p>Задача RTOS использует ulTaskNotifyTake() для блокирования в ожидании значения уведомления о задаче. Это действие не потребляет процессорного времени, пока задача находится в заблокированном состоянии.</p>
<p>Примечание: каждое уведомление в массиве работает независимо — задача может быть заблокирована только одним уведомлением в массиве и не будет разблокирована уведомлением, отправленным в любой другой индекс массива.</p>
<p>configUSE_TASK_NOTIFICATIONS должен быть равно 1 в FreeRTOSConfig.h (или не определён), чтобы эти макросы были доступны. Константа configTASK_NOTIFICATION_ARRAY_ENTRIES задает количество индексов в массиве уведомлений каждой задачи.</p>
<p>До FreeRTOS версии 10.4.0 каждая задача имела единственное “значение уведомления” и все функции API уведомлений о задачах работали с этим значением. Замена одного значения уведомления массивом значений уведомлений потребовала создания нового набора функций API, которые могли бы обращаться к конкретным уведомлениям внутри массива. ulTaskNotifyTake() остаётся обратно совместимой, всегда работая со значением уведомления по индексу 0 в массиве. Вызов ulTaskNotifyTake() эквивалентен вызову ulTaskNotifyTakeIndexed() с помощью uxIndexToWaitOn равным 0.</p>
<p><strong><em>Параметры:</em></strong></p>
<ul>
<li><p><strong><em>uxIndexToWaitOn</em></strong> - индекс в массиве значений уведомлений вызывающей задачи, по которому вызывающая задача будет ожидать ненулевого значения уведомления. uxIndexToWaitOn должен быть меньше, чем - configTASK_NOTIFICATION_ARRAY_ENTRIES. ulTaskNotifyTake() не имеет этого параметра и всегда ожидает уведомлений по индексу 0;</p></li>
<li><p><strong><em>xClearCountOnExit</em></strong> - если получено уведомление о задаче RTOS и для параметра xClearCountOnExit установлено значение pdFALSE, то значение уведомления задачи RTOS уменьшается перед завершением работы ulTaskNotifyTake(). Это эквивалентно уменьшению значения счетного семафора при успешном вызове функции xSemaphoreTake().</p></li>
</ul>
<p>Если получено уведомление о задаче RTOS и для параметра xClearCountOnExit установлено значение pdTRUE, то значение уведомления задачи RTOS сбрасывается на 0 перед завершением работы ulTaskNotifyTake(). Это эквивалентно тому, что значение двоичного семафора становится равным нулю (или пустым, или “недоступным”) после успешного вызова функции xSemaphoreTake();</p>
<ul>
<li><strong><em>xTicksToWait</em></strong> - максимальное время ожидания получения уведомления в заблокированном состоянии, если уведомление еще не находится на рассмотрении функции ulTaskNotifyTake(). Задача RTOS не потребляет процессорное время, когда находится в заблокированном состоянии. Время указывается в тактовых периодах RTOS. <strong><em>pdMS_TO_TICKS()</em></strong> - этот макрос можно использовать для преобразования времени, указанного в миллисекундах, во время, указанное в тиках.</li>
</ul>
<p><strong><em>Возврат:</em></strong></p>
<p>Значение уведомления о задаче до его уменьшения или очистки.</p>
<h6 id="к-содержанию-3"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="пример-использования-уведомления-для-синхронизации-прерывания-с-задачей">Пример использования уведомления для синхронизации прерывания с задачей</h3>
<p>В листинге ниже показано приложение с задачей, которая блокируется на уведомлении. Если бы задача блокировалась на семафоре, она бы вызывала функцию xSemaphoreTake() API, но поскольку задача использует уведомление, она вместо этого вызывает функцию ulTaskNotifyTake() API. Функция ulTaskNotifyTake() всегда использует уведомление с индексом 0. Рекомендуется использовать ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake(), чтобы использовать уведомление по любому конкретному индексу массива.</p>
<h4 id="использовать-уведомления-для-синхронизации-прерывания-с-задачей-и-выполнения-обработки-в-блокированном-состоянии"><a href="NotificForSynchro/NotificForSynchro.ino">Использовать уведомления для синхронизации прерывания с задачей и выполнения обработки в блокированном состоянии</a></h4>
<h6 id="к-содержанию-4"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="функции-с-передачей-величин-uint32t-через-уведомления">Функции с передачей величин uint32t через уведомления</h3>
<h4 id="xtasknotify-xtasknotifyindexed">xTaskNotify, xTaskNotifyIndexed</h4>
<p>task.h</p>
<pre><code>BaseType_t xTaskNotify( 
   TaskHandle_t xTaskToNotify,
   uint32_t ulValue,
   eNotifyAction eAction 
);


BaseType_t xTaskNotifyIndexed( 
   TaskHandle_t xTaskToNotify,
   UBaseType_t uxIndexToNotify,
   uint32_t ulValue,
   eNotifyAction eAction 
);
</code></pre>
<p>Функция <strong><em>xTaskNotify()</em></strong> используется для отправки события непосредственно в задачу RTOS и потенциальной разблокировки задачи, а также для дополнительного обновления одного из значений уведомления задачи-получателя одним из следующих способов: передачей 32-разрядного числа в значение уведомления, добавлением единицы (увеличения) к значению уведомления, манипуляцией одного или нескольких разрядов в значении уведомления, оставлением значения уведомления без изменений.</p>
<p>xTaskNotify() и <strong><em>xTaskNotifyIndexed()</em></strong> являются эквивалентными функциями с той лишь разницей, что xTaskNotifyIndexed() может работать с любым уведомлением о задаче в массиве, а xTaskNotify() всегда работает с уведомлением о задаче с индексом в массиве, равным 0.</p>
<p>Эти функции не должны вызываться из процедуры обслуживания прерываний (ISR). Вместо них следует использовать xTaskNotifyFromISR() и xTaskNotifyIndexedFromISR().</p>
<p><strong><em>Параметры:</em></strong></p>
<ul>
<li><p><strong><em>xTaskToNotify</em></strong> - дескриптор задачи RTOS, получающей уведомление. Дескриптор становится определенным, после создания задачи. Кроме этого получить дескриптор задачи можно по имени задачи с помощью функции xTaskGetHandle(). Функция API <strong><em>xTaskGetCurrentTaskHandle()</em></strong> возвращает дескриптор текущей выполняемой задачи RTOS;</p></li>
<li><p><strong><em>uxIndexToNotify</em></strong> - индекс в массиве значений уведомлений целевой задачи, на который должно быть отправлено уведомление. Значение uxIndexToNotify должно быть меньше значения configTASK_NOTIFICATION_ARRAY_ENTRIES. Функция xTaskNotify() не имеет этого параметра и всегда отправляет уведомления с индексом 0;</p></li>
<li><p><strong><em>ulValue</em></strong> - переданное значение уведомления целевой задачи, которое при приёме может быть изменено в соответствии со значением параметра <strong><em>eAction</em></strong>;</p></li>
<li><p><strong><em>eAction</em></strong> - перечисляемый тип, который может принимать одно из значений, описанных ниже, для выполнения соответствующего действия:</p></li>
<li><p><strong><em>eNoAction</em></strong> - целевая задача получает событие, но значение ее уведомления не обновляется. В этом случае ulValue не используется;</p></li>
<li><p><strong><em>eSetBits</em></strong> - значение уведомления целевой задачи будет побитово объединено с ulValue. Например, если значение ulValue равно 0x01, то в значении уведомления целевой задачи будет установлен бит 0. Аналогично, если значение ulValue равно 0x04, то в значении уведомления целевой задачи будет установлен бит 2. Таким образом, механизм уведомлений задач RTOS можно использовать в качестве облегчённой альтернативы группе событий;</p></li>
<li><p><strong><em>eIncrement</em></strong> - значение уведомления для целевой задачи будет увеличено на единицу, что сделает вызов функции xTaskNotify() эквивалентным вызову функции xTaskNotifyGive(). В этом случае ulValue не используется.</p></li>
<li><p><strong><em>eSetValueWithOverwrite</em></strong> - значение уведомления для целевой задачи обязательно устанавливается равным ulValue. Таким образом, механизм уведомления о задачах RTOS используется в качестве упрощенной альтернативы xQueueOverwrite();</p></li>
<li><p><strong><em>eSetValueWithoutOverwrite</em></strong> - если у целевой задачи еще нет ожидающего уведомления, то значения её уведомления будет установлено, как ulValue. Если у целевой задачи уже есть ожидающее уведомление, то значение уведомления не обновляется, поскольку это привело бы к перезаписи предыдущего значения до его использования. В этом случае вызов функции xTaskNotify() завершается ошибкой и возвращается pdFALSE.</p></li>
</ul>
<p>Таким образом, механизм уведомления о задачах RTOS используется в качестве упрощенной альтернативы xQueueSend() для очереди длиной 1.</p>
<p><strong><em>Возврат:</em></strong></p>
<p>pdPASS возвращается во всех случаях, кроме случаев, когда для параметра eAction установлено значение eSetValueWithoutOverwrite, а значение уведомления целевой задачи не может быть обновлено, поскольку для целевой задачи уже было получено ожидающее уведомление.</p>
<h4 id="xtasknotifyfromisr-xtasknotifyindexedfromisr">xTaskNotifyFromISR, xTaskNotifyIndexedFromISR</h4>
<p>task.h</p>
<pre><code>BaseType_t xTaskNotifyFromISR( 
   TaskHandle_t xTaskToNotify,
   uint32_t ulValue,
   eNotifyAction eAction,
   BaseType_t *pxHigherPriorityTaskWoken 
);

BaseType_t xTaskNotifyIndexedFromISR( 
   TaskHandle_t xTaskToNotify,
   UBaseType_t uxIndexToNotify,
   uint32_t ulValue,
   eNotifyAction eAction,
   BaseType_t *pxHigherPriorityTaskWoken 
);</code></pre>
<p>Эти функции являются аналогами xTaskNotify() и xTaskNotifyIndexed(), но которые следует использовать в подпрограммах обслуживания прерываний (ISR). Все параметры <strong><em>xTaskNotifyFromISR</em></strong>, <strong><em>xTaskNotifyIndexedFromISR</em></strong> идентичны аналогам, но добавляется еще один параметр:</p>
<ul>
<li><strong><em>pxHigherPriorityTaskWoken</em></strong>: <em>pxHigherPriorityTaskWoken должен быть инициализирован значением pdFALSE. Функция xTaskNotifyFromISR() установит </em>pxHigherPriorityTaskWoken в значение pdTRUE, если отправка уведомления привела к разблокировке задачи, а приоритет разблокированной задачи выше, чем у выполняемой в данный момент задачи. Если функция xTaskNotifyFromISR() установит это значение в pdTRUE, то перед завершением прерывания необходимо запросить переключение контекста - portYIELD_FROM_ISR(xHigherPriorityTaskWoken. pxHigherPriorityTaskWoken — необязательный параметр, который можно установить в NULL.</li>
</ul>
<p><strong><em>Возврат:</em></strong></p>
<p>pdPASS возвращается во всех случаях, кроме тех, когда для eAction установлено значение eSetValueWithoutOverwrite, а значение уведомления целевой задачи не может быть обновлено, поскольку у целевой задачи уже есть ожидающее выполнения уведомление.</p>
<h4 id="xtasknotifywait-xtasknotifywaitindexed">xTaskNotifyWait, xTaskNotifyWaitIndexed</h4>
<p>task.h</p>
<pre><code>BaseType_t xTaskNotifyWait( 
   uint32_t ulBitsToClearOnEntry,
   uint32_t ulBitsToClearOnExit,
   uint32_t *pulNotificationValue,
   TickType_t xTicksToWait 
);

BaseType_t xTaskNotifyWaitIndexed( 
   UBaseType_t uxIndexToWaitOn,
   uint32_t ulBitsToClearOnEntry,
   uint32_t ulBitsToClearOnExit,
   uint32_t *pulNotificationValue,
   TickType_t xTicksToWait 
);</code></pre>
<p>Функция <strong><em>xTaskNotifyWait()</em></strong> ожидает, с необязательным таймаутом, получения уведомления от вызывающей задачи. Если принимающая задача RTOS уже была заблокирована в ожидании уведомления, то при получении ожидаемого уведомления принимающая задача RTOS будет выведена из заблокированного состояния, а уведомление удалено.</p>
<p><strong><em>xTaskNotifyWait() и xTaskNotifyWaitIndexed()</em></strong> являются эквивалентными макросами с той лишь разницей, что xTaskNotifyWaitIndexed() может работать с любым уведомлением о задаче в массиве, а xTaskNotifyWait() всегда работает с уведомлением о задаче с индексом массива 0.</p>
<p><strong><em>Параметры:</em></strong></p>
<ul>
<li><p><strong><em>uxIndexToWaitOn</em></strong> - индекс в массиве значений уведомлений вызывающей задачи, по которому вызывающая задача будет ожидать получения уведомления;</p></li>
<li><p><strong><em>ulBitsToClearOnEntry</em></strong> - вход в систему, все биты, заданные в ulBitsToClearOnEntry, будут удалены в значении уведомления вызывающей задачи при входе в функцию xTaskNotifyWait() (до того, как задача начнет ожидать нового уведомления) при условии, что уведомление еще не находится в ожидании при вызове функции xTaskNotifyWait().</p></li>
</ul>
<p>Например, если ulBitsToClearOnEntry равен 0x01, то бит 0 значения уведомления задачи будет очищен при входе в функцию. Установка значения ulBitsToClearOnEntry в 0xffffffffff (<strong><em>ULONG_MAX</em></strong>) очистит все биты в значении уведомления о задаче, фактически установив значение равным 0;</p>
<ul>
<li><strong><em>ulBitsToClearOnExit</em></strong> - все биты, заданные в ulBitsToClearOnExit, будут удалены в значении уведомления вызывающей задачи RTOS перед завершением работы функции xTaskNotifyWait(), если уведомление было получено. Биты очищаются после сохранения значения уведомления задачи RTOS в *pulNotificationValue;</li>
</ul>
<p>Например, если значение ulBitsToClearOnExit равно 0x03, то биты 0 и 1 значения уведомления задачи будут удалены перед завершением работы функции. Установка значения ulBitsToClearOnExit равным 0xffffffff (ULONG_MAX) очистит все биты в значении уведомления о задаче, фактически установив значение равным 0;</p>
<ul>
<li><p><strong><em>pulNotificationValue</em></strong> используется для передачи значения уведомления задачи RTOS. Значение, скопированное в *pulNotificationValue, является значением уведомления задачи RTOS в том виде, в каком оно было до того, как какие-либо биты были удалены из-за установки ulBitsToClearOnExit. Если значение уведомления не требуется, то значение pulNotificationValue устанавливается равным NULL;</p></li>
<li><p><strong><em>xTicksToWait</em></strong> - максимальное время ожидания получения уведомления в заблокированном состоянии, если уведомление еще не находится на рассмотрении при вызове функции xTaskNotifyWait(). Задача RTOS не потребляет процессорного времени, когда она находится в заблокированном состоянии. Время указано в тиках CPU. Макрос <strong><em>pdMS_TO_TICKS()</em></strong> может использоваться для преобразования времени, указанного в миллисекундах, во время, указанное в тиках.</p></li>
</ul>
<p><strong><em>Возврат:</em></strong></p>
<p>pdTRUE, если уведомление было получено, или уведомление уже находилось на рассмотрении, когда была вызвана функция xTaskNotifyWait(). pdFALSE, если время ожидания вызова функции xTaskNotifyWait() истекло до получения уведомления.</p>
<h6 id="к-содержанию-5"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="пример-использования-уведомления-для-отправки-значения-из-isr-в-задачу">Пример использования уведомления для отправки значения из ISR в задачу</h3>
<p>В следующем примере использование уведомлений выходит за рамки простого повторения поведения семафора и демонстрирует, как отправлять данные с помощью уведомлений. Отправка данных требует минимальных дополнительных затрат.</p>
<p>В листинге показана структура функции, которая возвращает результат аналого-цифрового преобразования (АЦП). Задача, которая вызывает функцию, ожидает результат преобразования в заблокированном состоянии, поэтому она не расходует ресурсы процессора. Результат отправляется ей из подпрограммы обработки прерываний (ISR) в конце преобразования. В этом сценарии необходимо использовать несколько более сложные функции API xTaskNotify() и xTaskNotifyWait(). Как и прежде, xTaskNotify() и xTaskNotifyWait() работают с уведомлением по индексу 0 в массиве уведомлений. Используйте xTaskNotifyIndexed() и xTaskNotifyWaitIndexed() для работы с любым конкретным индексом в массиве.</p>
<h4 id="использовать-уведомления-для-отправки-значения-из-isr-в-задачу"><a href="NotificValueFromISR/NotificValueFromISR.ino">Использовать уведомления для отправки значения из ISR в задачу</a></h4>
<h6 id="к-содержанию-6"><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8">к содержанию</a></h6>
<hr />
<h3 id="заключение">Заключение</h3>
<p>FreeRTOS — это устоявшийся продукт, который развивался на протяжении почти двух десятилетий и продолжает развиваться, включая дополнительные функции, адаптированные к наиболее распространённым сценариям использования. Эти функции включают уведомления о задачах, буферы сообщений и потоковые буферы.</p>
<p>Разработчикам следует использовать эти адаптированные функции вместо более старых функций FreeRTOS, потому что они меньше по размеру и работают быстрее, но новые разработчики FreeRTOS часто упускают их из виду, потому что эти концепции не описаны в стандартных текстах по ОС.</p>
<p>Оригинальные функции FreeRTOS по-прежнему будут всегда доступны для покрытия всех вариантов использования, но в большинстве приложений использование комплексных функций, таких как очереди и семафоры, может быть скорее исключением, чем нормой.</p>
<h3 id="библиография">Библиография</h3>
<h4 id="rtos-task-notifications"><a href="https://freertos.org/Documentation/02-Kernel/04-API-references/05-Direct-to-task-notifications/00-RTOS-task-notifications">RTOS Task Notifications</a></h4>
<h4 id="уменьшение-объема-оперативной-памяти-и-ускорение-с-помощью-уведомлений-freertos"><a href="https://freertos.org/Community/Blogs/2020/decrease-ram-footprint-and-accelerate-execution-with-freertos-notifications">Уменьшение объема оперативной памяти и ускорение с помощью уведомлений FreeRTOS</a></h4>
<h4 id="freertos-direct-to-task-notifications"><a href="https://freertos.org/Documentation/02-Kernel/02-Kernel-features/03-Direct-to-task-notifications/01-Task-notifications">FreeRTOS direct to task notifications</a></h4>
</body>
</html>
