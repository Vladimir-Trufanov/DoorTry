<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="использование-таймерных-прерываний-в-esp32-2024-11-03"><a href="https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/ispolzovanie-tajmernyh-preryvanij-v-esp32/ispolzovanie-tajmernyh-preryvanij-v-esp32.md">Использование таймерных прерываний в Esp32</a> [2024-11-03]</h2>
<p>Данный материал опирается на документацию ESPRESSIF по таймерам <a href="https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html" class="uri">https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html</a>.</p>
<p>В контроллерах ESP32 содержится от 2 до 4 аппаратных таймеров. Все они представляют собой 64-битные (54-битные для ESP32-C3) универсальные таймеры на основе 16-битных предварительных масштабирующих устройств и 64-битных (54-битных для ESP32-C3) счётчиков с возможностью автоматической перезагрузки.</p>
<pre><code>Контроллер ESP32       Количество таймеров
------------------------------------------
ESP32                  4
ESP32-S2               4
ESP32-S3               4
ESP32-C3               2
ESP32-C6               2
ESP32-H2               2</code></pre>
<h4 id="что-такое-спин-блокировки">Что такое “спин-блокировки”?</h4>
<p>В представленном далее примере обработчик прерывания от таймера содержит критическую секцию, связанную со “спин-блокировкой” процессора (ядра).</p>
<p>При использовании обычных блокировок (мьютексов) операционная система переводит ваш поток в состояние WAIT и прерывает его (“вытесняет задачу”), планируя другие потоки на том же ядре. Это снижает производительность, <strong><em>когда время ожидания очень короткое</em></strong>, потому что теперь ваш поток должен ждать прерывания, чтобы снова получить процессорное время. Кроме этого затрачиваются накладные расходы на переключение задач.</p>
<p>Спин-блокировки (<a href="https://ru.wikipedia.org/wiki/Спин-блокировка">спинлоки</a>) не вызывают вытеснения потока, а заставляют его ждать в цикле (“спине”), пока ядро не снимет блокировку. То есть задача продолжает работать в кванте, выделенном ей операционной системой.</p>
<p>Cпин-блокировки полезны только в тех местах, где время ожидания меньше кванта (читай: миллисекунд). Если время ожидания неизвестно, то спин-блокировки неэффективны, так как потребляется 100% процессорного времени на ожидающем ядре при выполнении проверки, доступна ли спин-блокировка. Это не позволяет другим потокам работать на этом ядре до истечения кванта времени.</p>
<h4 id="критические-разделы-и-отключение-прерываний">Критические разделы и отключение прерываний</h4>
<p>В стандартной версии FreeRTOS критические секции реализованы с помощью <strong><em>taskENTER_CRITICAL()</em></strong> и <strong><em>portDISABLE_INTERRUPTS()</em></strong> вызовов. Это предотвращает принудительное переключение контекста и обслуживание ISR во время критической секции. Таким образом, критические секции используются в стандартной версии FreeRTOS в качестве надёжного метода защиты от одновременного доступа.</p>
<p><a href="https://docs.espressif.com/projects/esp-idf/en/v4.3.1/esp32/api-guides/freertos-smp.html">Но в ESP32/8266 нет аппаратного метода, с помощью которого ядра могли бы отключать прерывания друг друга</a>. Вызов portDISABLE_INTERRUPTS() не повлияет на прерывания другого ядра. Таким образом, отключение прерываний НЕ является эффективным методом защиты от одновременного доступа к общим данным, поскольку другое ядро может свободно обращаться к данным, даже если текущее ядро отключило собственные прерывания.</p>
<p>По этой причине в ESP FreeRTOS критические секции реализуются с помощью специальных мьютексов, на которые ссылаются объекты <strong><em>portMUX_Type</em></strong>. Они реализованы на основе специального компонента <strong><em>спин-блокировки</em></strong>. При вызове <strong><em>taskENTER_CRITICAL</em></strong> или <strong><em>taskEXIT_CRITICAL</em></strong> в качестве аргумента передаётся объект спин-блокировки, который связан с общим ресурсом, требующим защиты доступа.</p>
<p>При входе в критическую секцию в ESP вызывающее ядро отключает прерывания, как и в стандартной реализации FreeRTOS, а затем получает спин-блокировку и входит в критическую секцию. На этом этапе другое ядро не затронуто, если только оно не входит в свою собственную критическую секцию и не пытается получить ту же спин-блокировку. В этом случае оно будет ожидать освобождения блокировки. Таким образом, реализация критических секций в ESP32/8266 FreeRTOS позволяет ядру получить защищённый доступ к общему ресурсу, не отключая другое ядро. Другое ядро будет затронуто только в том случае, если оно попытается одновременно получить доступ к тому же ресурсу.</p>
<p>Для обслуживания критического раздела ESP-IDF FreeRTOS отделяются функции для обработчиков прерываний и в составе задач, и выделяются в группы следующим образом:</p>
<p>taskENTER_CRITICAL(mux), taskENTER_CRITICAL_ISR(mux), portENTER_CRITICAL(mux), portENTER_CRITICAL_ISR(mux) определены для вызова внутренней функции <strong><em>vPortEnterCritical()</em></strong></p>
<p>taskEXIT_CRITICAL(mux), taskEXIT_CRITICAL_ISR(mux), portEXIT_CRITICAL(mux), portEXIT_CRITICAL_ISR(mux) определены для вызова внутренней функции <strong><em>vPortExitCritical()</em></strong></p>
<p>portENTER_CRITICAL_SAFE(mux), portEXIT_CRITICAL_SAFE(mux) определяют <strong><em>контекст выполнения</em></strong>, то есть ISR или Non-ISR и вызывают соответствующие функции критического раздела (port*_CRITICAL в Non-ISR и port*_CRITICAL_ISR в ISR).</p>
<p>Следует отметить, что при изменении стандартного кода FreeRTOS для обеспечения совместимости с ESP-IDF FreeRTOS можно легко изменить тип вызываемого критического раздела, поскольку все они определены для вызова одной и той же функции. Пока при входе и выходе используется одна и та же спин-блокировка, точный макрос или функция, используемые для вызова, не имеют значения.</p>
<h4 id="пример-прерывания-от-таймера-повтора"><a href="RepeatTimer/RepeatTimer.ino">Пример прерывания от таймера повтора</a></h4>
<p>В скетче запускается таймерное прерывание каждую секунду, которое освобождает семафор для основного цикла. В основном цикле при обнаружении свободного семафора в последовательный порт выводится значение счётчика прерываний и время очередного прерывания.</p>
<p>Работу таймера можно остановить, замкнув контакт IO0 на землю (GND).</p>
<h4 id="пример-прерывания-и-управления-программным-сторожевым-таймером"><a href="WatchdogTimer/WatchdogTimer.ino">Пример прерывания и управления программным сторожевым таймером</a></h4>
<p>В скетче задается время сторожевому таймеру для перезагрузки контроллера, равное 3 секундам. Но пока контакт IO0 не замкнут на GND, скетч работает 1 секунду и сбрасывает сторожевой таймер, предотвращая перезагрузку контроллера. После замыкания контакта скетч переходит в бесконечный цикл, что вызывает прерывание через 3 секунды и перезагрузку контроллера.</p>
</body>
</html>
