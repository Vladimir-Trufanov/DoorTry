<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="все-про-встроенную-оперативную-память-esp32-2024-11-23"><a href="https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/vse-pro-sram-pamyat/vse-pro-sram-pamyat.md">Все про встроенную оперативную память Esp32</a> [2024-11-23]</h2>
<h3 id="общие-конструкции">Общие конструкции</h3>
<p>FreeRTOS (операционная система ESP32) использует общие конструкции компьютерной архитектуры:</p>
<p><strong><em>статическая память</em></strong> – память, выделяемая под переменные во время компиляции;</p>
<p><strong><em>heap или куча</em></strong> – динамическая память, выделяемая под задачи приложения и нужды FreeRTOS, вызовами специальных функций malloc и calloc и другими,</p>
<p><strong><em>стек</em></strong> – динамическая память внутри кучи, автоматически заполняющаяся и освобождающаяся каждой задачей (потоком) приложения в процессе выполнения.</p>
<p>При этом сам микроконтроллер ESP32 включает несколько типов оперативной памяти ( RAM ):</p>
<p><strong><em>DRAM (ОЗУ данных)</em></strong> — это память, которая подключена к шине данных ЦП и используется для хранения данных. Это наиболее распространенный вид памяти, доступ к которому осуществляется в виде кучи и стека. При запуске куча DRAM содержит всю память данных, которая не выделена приложением статически. Уменьшение статически выделяемых буферов увеличивает объем доступной свободной кучи и наоборот.</p>
<p><strong><em>IRAM (ОЗУ инструкций)</em></strong> — это память, которая подключена к шине инструкций ЦП и обычно содержит только исполняемые данные (т.е. инструкции, или скомпилированную программу). Важно понимать: в этой части оперативной памяти находится не вся ваша программа, а только отдельные функции, помещенные атрибутом IRAM_ATTR, а весь остальной код находится во flash-памяти и вызывается прямо оттуда. Однако её в некоторых случаях можно использовать и в качестве обычной памяти. Если доступ к IRAM осуществляется как доступ к общей памяти, все обращения должны быть в 32-битных единицах.</p>
<p>D/IRAM — это ОЗУ, которое подключено к шине данных ЦП и шине инструкций, поэтому может использоваться как ОЗУ инструкций, так и ОЗУ данных.</p>
<p>Также к ESP32 можно подключить внешнюю <strong><em>SPI RAM</em></strong>. Внешняя оперативная память интегрирована в карту памяти ESP32 через кеш в DRAM, и доступ к ней осуществляется аналогично DRAM.</p>
<p><img src="vse-pro-sram-pamyat.jpg" /></p>
<hr />
<h3 id="оргaнизация-dram"><a href="#%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-dram">Оргaнизация DRAM</a></h3>
<h3 id="оргaнизация-iram"><a href="#%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-iram">Оргaнизация IRAM</a></h3>
<h3 id="выделeние-памяти-кучи"><a href="#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-%D0%BA%D1%83%D1%87%D0%B8">Выделeние памяти кучи</a></h3>
<h3 id="скетч-показать-заполнение-свободной-памяти-как-внутренней-так-и-внешней"><a href="#%D0%BF%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D1%8C-%D0%B7%D0%B0%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B5%D0%B9-%D0%B8-%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B5%D0%B9-%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8">Скетч “Показать заполнение свободной памяти, как внутренней, так и внешней”</a></h3>
<h3 id="библиoграфия"><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F">Библиoграфия</a></h3>
<hr />
<h3 id="организация-dram">Организация DRAM</h3>
<p>В Esp32 размещено 520 КБ встроенной оперативной памяти для данных и инструкций (SRAM), которая разделена на три части: Internal SRAM0 (192 КБ), Internal SRAM1 (128 КБ) и Internal SRAM2 (200 Кбайт).</p>
<p>Часть SRAM предоставляется шине памяти команд (IRAM) и шине памяти данных (DRAM). Память команд является исполняемой и может быть прочитана или записана только в виде 4-байтовых выровненных слов. Память данных не является исполняемой и может быть доступна только для чтения или записи в виде отдельных байтов.</p>
<figure>
<img src="shema-vnutrennej-operativnoj-pamyati.jpg" alt="Схема внутренней оперативной памяти" /><figcaption>Схема внутренней оперативной памяти</figcaption>
</figure>
<p>Как правило, приложениям не хватает памяти для хранения данных и SRAM1 отдается шине данных. В обычном делении оперативной памяти 192 КБ получает IRAM, 328 КБ DRAM.</p>
<p>Хотя для приложения это не имеет большого значения, так как они не пересекаются, следует обратить внимание, что направление адресного диапазона для IRAM и DRAM противоположное.</p>
<figure>
<img src="obychnaya-shema-deleniya-pamyati-mezhdu-shinami.jpg" alt="Обычная схема деления памяти между шинами" /><figcaption>Обычная схема деления памяти между шинами</figcaption>
</figure>
<p>Адреса DRAM начинаются с конца SRAM2 и увеличиваются в обратном направлении.</p>
<p>Первые 8 КБ (0x3FFA_E000-0x3FFA_FFFF) используются в качестве памяти для хранения данных некоторых функций ПЗУ. Затем компоновщик размещает инициализированный сегмент данных (Data Segment). Следующим идет сегмент BSS - «block started by symbol», где хранятся неинициализированные глобальные и статические переменные.</p>
<p>Память, оставшаяся после выделения сегментов данных и BSS, настраивается для использования в качестве кучи. Именно сюда обычно помещается динамическая память.</p>
<p>Так как размер сегментов данных и BSS зависит от приложения, то каждое приложение изначально имеет разный доступный размер кучи.</p>
<p>В куче есть две области (0x3FFE_0000 - 0x3FFE_0440) 1088 байт и (0x3FFE_3F20 - 0x3FFE_4350) 1072 байта, которые используются в качестве ПЗУ для хранения данных. Эти области помечены как зарезервированные, и распределитель кучи не выделяет память из этих областей.</p>
<blockquote>
<p>Данные, помеченные как <strong><em>static const</em></strong> (cтатические константы, то есть данные, значение которых можно только прочитать и нельзя изменить) сохраняют своё значение на всём протяжении работы программы. Область их видимости остаётся локальной: взаимодействовать с переменной можно только внутри блока кода, где она создана (и во всех вложенных в него).</p>
</blockquote>
<blockquote>
<p>По умолчанию статические константы размещаются во внешней флэш-памяти. Если необходимо их разместить в DRAM, то используется атрибут <strong><em><a href="">DRAM_ATTR</a></em></strong>.</p>
</blockquote>
<p><img src="organizaciya-dram.jpg" /></p>
<p>Когда функция Bluetooth включена, контроллеру Bluetooth необходимо использовать выделенную память для данных. Эта память используется в качестве памяти для данных и BSS контроллера, а также для передачи пакетов Bluetooth между программным и аппаратным обеспечением. Поэтому компоновщик резервирует 54 КБ памяти по умолчанию в диапазоне 0x3FFB_0000 - 0x3FFB_DB5C. Распределение сегментов данных и BSS приложения продолжается за пределами этого диапазона.</p>
<p>Когда приложение использует только функции BLE, часть памяти контроллера Bluetooth может быть возвращена в кучу. Объём памяти, который освобождается и добавляется в кучу, составляет ~19 КБ.</p>
<blockquote>
<p>Bluetooth и BLE - это технологии беспроводной связи, использующие протокол Bluetooth, но для разных целей и имеют разные характеристики. Bluetooth требует высокой скорости передачи данных и доступа к питанию, в то время как BLE используется для маломощных приложений с низкой скоростью передачи данных от небольших батарей, таких как устройства IoT.</p>
</blockquote>
<p>Когда включена трассировка, то отбирается от кучи и фиксируется память Trace Memory объёмом 32 КБ в конце DRAM: 0x3FF8_0000 - 0x3FFF_FFFF.</p>
<h6 id="в-начало"><a href="#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8">в начало</a></h6>
<h3 id="организация-iram">Организация IRAM</h3>
<p>192 КБ доступной оперативной памяти в ESP32 используется для выполнения кода, а также частично в качестве кэш-памяти для доступа к флэш-памяти (и PSRAM).</p>
<ul>
<li><p>Первые 32 КБ оперативной памяти используются в качестве кэша ЦП0, а следующие 32 КБ - в качестве кэша ЦП1. Это статически задано аппаратно и не может быть изменено.</p></li>
<li><p>После первых 64 КБ скрипт компоновщика начинает размещать текстовую область в IRAM.</p></li>
</ul>
<p>Сначала он размещает все векторы прерываний, а затем весь текст в скомпилированном приложении, который помечен для размещения в IRAM.</p>
<blockquote>
<p>По умолчанию код программы в ESP32 размещается во внешней флэш-памяти. Однако в определённых режимах (например, в обработчиках прерываний) external flash недоступен, поэтому код, который работает в таких режимах, должен быть размещён в IRAM. Иногда, по условиям работы приложения некоторые его части должны быть размещены в IRAM. Во всех этих случаях используется атрибут <strong><em><a href="#">IRAM_ATTR</a></em></strong>. Код функций, помеченный этим атрибутом, будет размещён в IRAM.</p>
</blockquote>
<ul>
<li>IRAM после текстового раздела остаётся неиспользуемым и добавляется в кучу.</li>
</ul>
<p><img src="organizaciya-iram.jpg" /></p>
<p>Кроме того, когда приложение работает в одноядерном режиме, CPU1 не функционирует, а его кэш не используется. В этом случае память кэша 0x4007_8000 - 0x4007_FFFF добавляется в кучу.</p>
<p>Неиспользуемая память IRAM, размещённая в куче, может быть доступна для динамического выделения.</p>
<h6 id="в-начало-1"><a href="#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8">в начало</a></h6>
<h3 id="выделение-памяти-кучи">Выделение памяти кучи</h3>
<p>При запуске куча DRAM содержит всю память для данных, которая не выделяется приложением статически. Уменьшение количества статически выделяемых буферов увеличивает объём доступной свободной кучи.</p>
<p>У каждой задачи FreeRTOS есть свой собственный стек. По умолчанию каждый из этих стеков выделяется из кучи при создании задачи.</p>
<p>При запуске куча IRAM содержит всю память инструкций, которая не используется исполняемым кодом приложения.</p>
<p>Для выделения памяти в куче без каких-либо особых соображений в большинстве целей функции malloc() достаточно. Однако для полного использования всех типов памяти и их характеристик есть распределитель памяти в куче на основе возможностей. Если вы хотите получить память с определёнными свойствами (например, память с поддержкой DMA или исполняемую память), вы можете создать маску для требуемых возможностей и передать её в heap_caps_malloc().</p>
<p>Например, при включении внешней оперативной памяти SPI SRAM, память для определенных целей может быть выделена в ней с помощью heap_caps_malloc(MALLOC_CAP_SPIRAM).</p>
<pre><code>// Определения выбора возможностей:

#define MALLOC_CAP_EXEC             (1&lt;&lt;0)  ///&lt; Memory must be able to run executable code
#define MALLOC_CAP_32BIT            (1&lt;&lt;1)  ///&lt; Memory must allow for aligned 32-bit data accesses
#define MALLOC_CAP_8BIT             (1&lt;&lt;2)  ///&lt; Memory must allow for 8/16/...-bit data accesses
#define MALLOC_CAP_DMA              (1&lt;&lt;3)  ///&lt; Memory must be able to accessed by DMA
#define MALLOC_CAP_PID2             (1&lt;&lt;4)  ///&lt; Memory must be mapped to PID2 memory space (PIDs are not currently used)
#define MALLOC_CAP_PID3             (1&lt;&lt;5)  ///&lt; Memory must be mapped to PID3 memory space (PIDs are not currently used)
#define MALLOC_CAP_PID4             (1&lt;&lt;6)  ///&lt; Memory must be mapped to PID4 memory space (PIDs are not currently used)
#define MALLOC_CAP_PID5             (1&lt;&lt;7)  ///&lt; Memory must be mapped to PID5 memory space (PIDs are not currently used)
#define MALLOC_CAP_PID6             (1&lt;&lt;8)  ///&lt; Memory must be mapped to PID6 memory space (PIDs are not currently used)
#define MALLOC_CAP_PID7             (1&lt;&lt;9)  ///&lt; Memory must be mapped to PID7 memory space (PIDs are not currently used)
#define MALLOC_CAP_SPIRAM           (1&lt;&lt;10) ///&lt; Memory must be in SPI RAM
#define MALLOC_CAP_INTERNAL         (1&lt;&lt;11) ///&lt; Memory must be internal; specifically it should not disappear when flash/spiram cache is switched off
#define MALLOC_CAP_DEFAULT          (1&lt;&lt;12) ///&lt; Memory can be returned in a non-capability-specific memory allocation (e.g. malloc(), calloc()) call
#define MALLOC_CAP_IRAM_8BIT        (1&lt;&lt;13) ///&lt; Memory must be in IRAM and allow unaligned access
#define MALLOC_CAP_RETENTION        (1&lt;&lt;14) ///&lt; Memory must be able to accessed by retention DMA
#define MALLOC_CAP_RTCRAM           (1&lt;&lt;15) ///&lt; Memory must be in RTC fast memory

#define MALLOC_CAP_INVALID          (1&lt;&lt;31) ///&lt; Memory can&#39;t be used / list end marker</code></pre>
<p>Для работ с функциями кучи требуется подключение заголовочного файла:</p>
<pre><code>#include &quot;esp_heap_caps.h&quot;</code></pre>
<blockquote>
<p>Вся память DRAM доступна побайтно, поэтому все кучи DRAM обладают возможностью MALLOC_CAP_8BIT . Пользователи могут вызвать heap_caps_get_free_size(MALLOC_CAP_8BIT) , чтобы узнать размер всех свободных куч DRAM.</p>
</blockquote>
<pre><code>// Получить общий размер всех областей памяти, обладающих заданными
// возможностями. Эта функция берёт все регионы, в которых могут быть
// выделены заданные возможности, и суммирует занимаемую ими площадь
//
// Параметр: caps - побитовое ИЛИ флагов MALLOC_CAP_*, указывающих на тип памяти
// Возврат: общий размер в байтах
size_t heap_caps_get_total_size(uint32_t caps);

// Получить общий свободный объём всех регионов с заданными возможностями.
// Эта функция берёт все регионы, в которых могут быть выделены заданные
// возможности, и суммирует имеющееся в них свободное пространство.
//
// Примечание. Обратите внимание, что из-за фрагментации кучи, вероятно, 
// невозможно выделить один блок памяти такого размера. Для этого
// используйте heap_caps_get_largest_free_block().
//
// Параметр: caps - побитовое ИЛИ флагов MALLOC_CAP_*, указывающих на тип памяти
// Возврат: количество свободных байтов в регионах
size_t heap_caps_get_free_size(uint32_t caps);

// Получить общую минимальную свободную память для всех регионов 
// с заданными возможностями. Эта функция добавляет метки всех регионов,
// способных предоставить память с заданными характеристиками.
//
// Примечание. Обратите внимание, что результат может быть меньше
//   глобального минимального объёма доступной кучи такого типа за всё
//   время, так как «нижние границы» отслеживаются для каждой области
//   отдельно. Кучи отдельных регионов могли достичь «нижних границ» в
//   разные моменты времени. Однако этот результат всё равно даёт
//   представление о «наихудшем случае» для минимального объёма
//   свободной кучи за всё время.
//
// Параметр: caps - побитовое ИЛИ флагов MALLOC_CAP_*, указывающих на тип памяти
// Возврат: количество свободных байтов в регионах
size_t heap_caps_get_minimum_free_size(uint32_t caps);</code></pre>
<pre><code>// https://microsin.ru/programming/arm/esp32-c3-heap-memory-allocation.html

   DRAM позволяет выделять память с побайтным доступом MALLOC_CAP_8BIT
(память можно читать и записывать по байтовому адресу). 
   При вызове функции malloc() её реализация вызывает внутри себя
heap_caps_malloc(size, MALLOC_CAP_8BIT), чтобы выделить DRAM с возможностью 
побайтной адресации. 
   Чтобы узнать свободную область кучи DRAM во время выполнения кода,
следует вызывать heap_caps_get_free_size(MALLOC_CAP_8BIT).</code></pre>
<h6 id="в-начало-2"><a href="#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8">в начало</a></h6>
<h3 id="показать-заполнение-внутренней-и-внешней-свободной-памяти">Показать заполнение внутренней и внешней свободной памяти</h3>
<p>В следующем примере в последовательный порт выводится постоянно увеличивающаяся строка, на которую требуется все большее и большее пространство оперативной памяти.</p>
<h4 id="stackfiller---показать-заполнение-внутренней-и-внешней-свободной-памяти"><a href="StackFiller/StackFiller.ino">StackFiller - показать заполнение внутренней и внешней свободной памяти</a></h4>
<p>В протоколе примера видно, что вначале операционная система выделяла приложению встроенную память. Затем, когда было занято критически допустимое пространство встроенной памяти (на 8-мом цикле), FreeRTOS переключила задачу на внешнюю память, а часть, было занятой, встроенной памяти вернула в кучу.</p>
<p>Протокол вывода приложения в последовательный порт:</p>
<pre><code>Цикл №1
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348668
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! 
Длина строки: 57

Цикл №2
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348604
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 114

Цикл №3
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348492
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 228

Цикл №4
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348268
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 456

Цикл №5
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 347804
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 912

Цикл №6
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 346892
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 1824

Цикл №7
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 345068
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4192124
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 3648

Цикл №8
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4184796
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 7296

Цикл №9
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4177500
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 14592

Цикл №10
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4162908
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 29184

Цикл №11
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4133724
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 58368

Цикл №12
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         4075356
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 116736

Цикл №13
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         3958620
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 233472

Цикл №14
Общий размер ВСТРОЕННОЙ памяти:     380580
Оставшаяся доступная память в куче: 348748
Общий размер SPI PSRAM:             4194304
Количество свободной PSRAM:         3725148
Строка становится всё длиннее! Строка становится всё длиннее! Строка становится всё длиннее! 
Длина строки: 466944</code></pre>
<h3 id="библиография">Библиография</h3>
<h4 id="esp32-programmers-memory-model"><a href="https://developer.espressif.com/blog/esp32-programmers-memory-model/">ESP32 Programmers’ Memory Model</a></h4>
<h4 id="типы-памяти-esp-idf-espressif-5.3.1"><a href="https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-guides/memory-types.html#memory-layout">Типы памяти ESP-IDF ESPRESSIF 5.3.1</a></h4>
<h4 id="распределение-памяти-в-esp32"><a href="https://kotyara12.ru/iot/esp32_memory/">Распределение памяти в ESP32</a></h4>
<h4 id="выделение-памяти-кучи-1"><a href="https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/mem_alloc.html">Выделение памяти кучи</a></h4>
<h4 id="отладка-памяти-кучи"><a href="https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/heap_debug.html">Отладка памяти кучи</a></h4>
<h6 id="в-начало-3"><a href="#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8">в начало</a></h6>
</body>
</html>
