<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="как-настроить-дату-и-время-в-esp32-ide-arduino-2024-11-14"><a href="https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/kak-nastroit-datu-i-vremya-v-esp32/kak-nastroit-datu-i-vremya-v-esp32.md">Как настроить дату и время в ESP32 IDE Arduino</a> [2024-11-14]</h2>
<p>В состав ESP32 входит два аппаратных таймера, которые могут использоваться для отслеживания системного времени в зависимости от назначения приложения и требований к точности системного времени:</p>
<p><strong><em>Таймер RTC:</em></strong> этот таймер позволяет отслеживать время в различных режимах сна, а также сохранять время при любых сбросах (за исключением сбросов при включении питания, которые сбрасывают таймер RTC). Отклонение частоты зависит от источников тактового сигнала таймера RTC и влияет на точность только в режимах сна, в этом случае время будет измеряться с разрешением 6,6667 мкс.</p>
<p><strong><em>Таймер с высоким разрешением:</em></strong> этот таймер недоступен в спящих режимах и не сохраняется после сброса, но обладает большей точностью. Таймер использует источник тактовых импульсов APB_CLK (обычно 80 МГц), отклонение частоты которого составляет менее ±10 частей на миллион. Время будет измеряться с точностью до 1 мкс.</p>
<blockquote>
<p>По умолчанию, для синхронизации системного времени используется комбинация обоих таймеров - RTC и высокого разрешения .</p>
</blockquote>
<p>Частотную работу таймера RTC обеспечивает одно из возможных устройств: два внутренних (встроенных) и два внешних. По умолчанию используется <strong><em>Internal 150 kHz RC oscillator</em></strong> . Он обеспечивает минимальное потребление тока в режиме глубокого сна и не зависит от каких-либо внешних компонентов. Однако на стабильность частоты этого источника тактового сигнала влияют колебания температуры, поэтому время может смещаться как в режиме глубокого сна, так и в режиме лёгкого сна.</p>
<p>Второй внутренний таймер, который может использоваться, <strong><em>Internal 8.5 MHz oscillator, divided by 256 (about 33 kHz)</em></strong>. Этот таймер обеспечивает более высокую стабильность частоты, чем Internal 150 kHz RC oscillator за счет более высокого (на 5 мкА) потребления тока в глубоком режиме сна.</p>
<p>И может быть подключен один из двух внешних таймеров: <strong><em>External 32 kHz crystal</em></strong> или <strong><em>External 32 kHz oscillator at 32K_XN pin</em></strong>.</p>
<p>После включения питания ESP32 начинает отсчитывать время в секундах “с начала эпохи” - 1 января 1900 года. Для того, чтобы прочитать время таймера платы, можно воспользоваться командой - <strong><em>gettimeofday()</em></strong>. Для немедленного обновления текущего времени используется функция <strong><em>settimeofday()</em></strong>.</p>
<p>Формат команд gettimeofday(), settimeofday() идентичный:</p>
<pre><code>int gettimeofday (struct timeval *tp, struct timezone *tzp);
int settimeofday (struct timeval *tp, struct timezone *tzp)</code></pre>
<p>Функция gettimeofday() получает, а функция settimeofday() устанавливает в системе представление о текущем времени. Текущее время выражается в секундах и микросекундах, прошедших по всемирному координированному времени с 00:00:00 (часов,минут,секунд) 1 января 1970 года.</p>
<p>Аргумент <strong><em>tp</em></strong> указывает на структуру timeval, которая включает в себя следующие элементы:</p>
<pre><code>struct timeval 
{
   long tv_sec;  /* секунды с 1 января 1970 года */
   long tv_usec; /* и микросекунды */
};</code></pre>
<p>Аргумент <strong><em>tzp</em></strong> содержит информацию о часовом поясе. См. <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv">TIMEZONE</a>, но в gettimeofday() и settimeofday() аргумент tzp игнорируется.</p>
<p>Если требуется узнать прошедшее время с начала эпохи с точностью до одной микросекунды, воспользуйтесь приведённым ниже фрагментом кода:</p>
<pre><code>struct timeval tv_now;
gettimeofday(&amp;tv_now, NULL);
int64_t time_us = (int64_t)tv_now.tv_sec * 1000000L + (int64_t)tv_now.tv_usec;</code></pre>
<p>Если нужно получить время с точностью до секунды, используйте следующий фрагмент кода:</p>
<pre><code>time_t now;
char strftime_buf[64];
struct tm timeinfo;

// Выбираем текущее время
time(&amp;now);
// Устанавливаем стандартное время для региона - Европа/Москва
// https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
setenv(&quot;TZ&quot;, &quot;MSK-3&quot;, 1);
tzset();

localtime_r(&amp;now, &amp;timeinfo);
strftime(strftime_buf, sizeof(strftime_buf), &quot;%c&quot;, &amp;timeinfo);
printf(&quot;Текущие дата и время в Петрозаводске: %s\n&quot;, strftime_buf);
</code></pre>
<p>Так как в программном обеспечении контроллера (и в показанном фрагменте) время представляется в формате UTC, то для настройки Esp32 следует правильно установить часовой пояс. Например, для использования австралийского восточного стандартного времени (AEST) с учетом перехода на летнее время следует указать - «AEST-10AEDT,M10.1.0,M4.1.0/3».</p>
<p>Части этого определения часового пояса следующие:</p>
<ul>
<li>AEST: восточное стандартное время Австралии;</li>
<li>-10: смещение UTC на 10 часов вперёд от всемирного координированного времени (UTC);</li>
<li>AEDT: восточное дневное время Австралии;</li>
<li>M10.1.0: переход на летнее время происходит в первое воскресенье октября;</li>
<li>M4.1.0/3: переход обратно на стандартное время происходит в первое воскресенье апреля с разницей в 3 часа по сравнению с UTC.</li>
</ul>
<p>Чтобы узнать о других определениях часовых поясов, обратитесь к <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv">базе данных часовых поясов Posix</a>.</p>
<p>Форматирование данных о текущем времени при выводе выполняется с помощью структуры данных - <a href="https://cplusplus.com/reference/ctime/tm/">struct tm</a> и по правилам для функции <a href="https://cplusplus.com/reference/ctime/strftime/">strftime()</a> - format time as string.</p>
<pre><code> &quot;%A, %B %d %Y %H:%M:%S&quot; - это спецификаторы формата,  которые определяют,  как
 в struct tm timeinfo; будет отформатирован текст, а члены tm struct следующие:
  
  Тип элемента Значение                        Диапазон
  -----------------------------------------------------
  tm_sec  int  секунды после минуты            0-61*
  tm_min  int  минуты после часа               0-59
  tm_hour int  часы с полуночи                 0-23
  tm_mday int  день месяца                     1-31
  tm_mon  int  месяцы с января                 0-11
  tm_year int  годы с 1900
  tm_wday  —   количество дней с воскресенья   0-6
  tm_yday  —   количество дней с 1 января      0-365
  tm_isdst —   флаг перехода на летнее время </code></pre>
<h3 id="сервер-времени-ntp">Сервер времени NTP</h3>
<p>NTP расшифровывается как «протокол сетевого времени», а сервер NTP — это специализированная компьютерная система, которая предоставляет точную информацию о времени для других интернет-устройств.</p>
<p>Клиент NTP регулярно опрашивает один или несколько серверов NTP, чтобы получить текущее время, и синхронизирует свои внутренние часы на основе полученной метки времени. ESP32 так же в качестве клиента ESP32 подключается через маршрутизатор и Wi-Fi к интернету, и инициирует подключение к пулу серверов NTP. Один из серверов NTP отвечает меткой времени, которую получает ESP32 и использует для настройки своих внутренних часов.</p>
<figure>
<img src="image-8.png" alt="ESP32 опрашивает NTP-серверы" /><figcaption>ESP32 опрашивает NTP-серверы</figcaption>
</figure>
<p>Сами серверы NTP организованы в иерархическую многоуровневую систему с высокоточными устройствами для измерения времени, такими как атомные часы, GNSS (включая GPS) или другие радиочасы (авторитетные источники времени). Отдельные уровни называются стратами.</p>
<figure>
<img src="image-18.png" alt="Иерархия службы NTP-сервера" /><figcaption>Иерархия службы NTP-сервера</figcaption>
</figure>
<p>Как правило, устройства подключаются не к конкретному серверу NTP (IP-адресу), а к пулу второго или третьего страта из множества серверов NTP.</p>
<p>Пул NTP — это динамическая коллекция сетевых серверов NTP. В следующей таблице показано количество серверов NTP в пуле ntp.org в разных географических регионах.</p>
<figure>
<img src="ActiveNTPservers.png" alt="Active NTP servers" /><figcaption>Active NTP servers</figcaption>
</figure>
<p>Пул серверов MSK-IX NTP Server: <strong><em>ntp.msk-ix.ru</em></strong> реализован в виде группировки серверов, размещенных в Москве, Санкт-Петербурге, Екатеринбурге и Новосибирске, и относится к высшему уровню точности (Stratum One Time Servers) в иерархической системе часовых уровней. В качестве эталонного сигнала времени используется сигнал глобальных спутниковых систем навигации ГЛОНАСС.</p>
<p>Серверы MSK-IX включены в международный пул NTP-серверов POOL.NTP.ORG.</p>
<p>При необходимости можно запрашивать время на серверах NTP в определённых местах или странах. Например, адрес «de.pool.ntp.org» относится к пулу серверов NTP в Германии (DE). Возможно использовать другие континентальные зоны, такие как Северная Америка, Океания или Азия. Можно добавить числовой префикс и использовать несколько имён серверов, например «0.de.pool.ntp.org», «1.de.pool.ntp.org».</p>
<p>В IDE Arduino есть несколько примеров подключения Esp32 к NTP-серверам для синхронизации системного времени контроллера.</p>
<figure>
<img src="ide-arduino.jpg" alt="Примеры подключения к пулу NTP, как NTPClient" /><figcaption>Примеры подключения к пулу NTP, как NTPClient</figcaption>
</figure>
<h4 id="скетч-пример-подключения-к-пулу-ntp-сервера"><a href="Advanced/Advanced.ino">Скетч “Пример подключения к пулу NTP-сервера”</a></h4>
<h3 id="stnp-против-ntp">STNP против NTP</h3>
<p>Существует два основных протокола для синхронизации времени. NTP (протокол сетевого времени) и SNTP (простой протокол сетевого времени). NTP более точный и сложный, а SNTP — упрощённая версия NTP.</p>
<p>SNTP был специально разработан для небольших компьютеров и микроконтроллеров. Он был спроектирован с учётом более низких требований к памяти и вычислительной мощности, чем NTP. Хотя SNTP гораздо менее точен, чем NTP, он всё равно обеспечивает точность времени в пределах 100 миллисекунд.</p>
<p>Как правило, он используется в небольших сетевых устройствах, таких как IP-камеры, видеорегистраторы, IP-телефоны, маршрутизаторы, потребительские устройства, а также в микроконтроллерах, таких как ESP32.</p>
<p>Для ESP32 основным и является протокол SNTP. Библиотека, которая синхронизирует системное время контроллера по этому протоколу подключается к скетчу следующим образом:</p>
<pre><code>#include &quot;esp_sntp.h&quot;</code></pre>
<p>В следующих примерах показано, как синхронизировать внутренние часы ESP32 со временем, полученным с пула серверов NTP по протоколу SNTP. Это позволяет ESP32 поддерживать точное время, периодически обновляя его с серверов в автоматическом режиме при подключенном WiFi.</p>
<p>Конечно WiFi потребляет ресурсы платы, но после синхронизации времени, он может быть отключен, а для работы с датой и временем будут использоваться свои таймеры контроллера.</p>
<p>Все примеры, опубликованные в статье, были отработаны на программном обеспечении в IDE Arduino для Esp32 от Espressif Systems версии 3.0.6 на контроллере AI-Thinker ESP32-CAM.</p>
<p>В первом примере происходит подключение к пулу серверов, выполняется синхронизация точного времени с внутренними часами контроллера, затем с интервалом в 10 секунд воспроизводится время с внутреннего таймера платы. Кроме этого в фоновом режиме, автоматически, при подключенном WiFi выполняются повторные синхронизации системного времени Esp32 с точным временем по SNTP.</p>
<h4 id="скетч-синхронизировать-дату-и-время-esp32-с-сервером-ntp-по-протоколу-sntp"><a href="SynchronizingESP32clock/SynchronizingESP32clock.ino">Скетч “Синхронизировать дату и время ESP32 с сервером NTP по протоколу SNTP”</a></h4>
<p>В следующем скетче при запуске контроллера проверяется системное время, если время еще не установлено, производится его синхронизация по протоколу SNTP с серверами точного времени, затем контроллер переводится в глубокий сон на несколько секунд, потом просыпается, показывает текущее время и повторяется перевод в глубокий сон.</p>
<p>Кроме этого контроллер использует память таймера RTC для хранения переменной, которая содержит количество перезагрузок ESP32. После каждого “просыпания” значение этого счетчика увеличивается на 1.</p>
<blockquote>
<p>Размер памяти RTC в ESP32 составляет 8 кбайт.</p>
</blockquote>
<h4 id="скетч-cинхронизировать-системное-время-перевести-устройство-вглубокий-сон-и-хранить-счетчик-запусков-в-памяти-rtc"><a href="LwIPSNTPexample/LwIPSNTPexample.ino">Скетч “Cинхронизировать системное время, перевести устройство в”глубокий сон&quot; и хранить счетчик запусков в памяти RTC“</a></h4>
<h3 id="библиография">Библиография</h3>
<h4 id="system-time---руководстве-по-программированию-системного-времени-для-esp32"><a href="https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/system_time.html">System Time - руководстве по программированию системного времени для ESP32</a></h4>
<h4 id="how-to-synchronize-esp32-clock-with-sntp-server"><a href="https://www.makerguides.com/how-to-synchronize-esp32-clock-with-sntp-server/">How to synchronize ESP32 clock with SNTP server</a></h4>
<h4 id="настенные-часы-с-синхронизацией-через-интернет"><a href="https://lesson.iarduino.ru/page/ntp_esp32/">Настенные часы с синхронизацией через интернет</a></h4>
</body>
</html>
